<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>The Edition Guide</title>
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">
        <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:500" rel="stylesheet" type="text/css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body class="light">
        <!-- Provide site root to javascript -->
        <script type="text/javascript">var path_to_root = "";</script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { } 
            if (theme === null || theme === undefined) { theme = 'light'; }
            document.body.className = theme;
            document.querySelector('html').className = theme + ' js';
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <ol class="chapter"><li class="affix"><a href="introduction.html">简介</a></li><li><a href="editions/index.html"><strong aria-hidden="true">1.</strong> 什么是版本(Editions)？</a></li><li><ol class="section"><li><a href="editions/transitioning-your-code-to-a-new-edition.html"><strong aria-hidden="true">1.1.</strong> 将你的代码迁移到新版本</a></li></ol></li><li><a href="rust-2015/index.html"><strong aria-hidden="true">2.</strong> Rust 2015</a></li><li><a href="rust-2018/index.html"><strong aria-hidden="true">3.</strong> Rust 2018</a></li><li><ol class="section"><li><a href="rust-2018/module-system/index.html"><strong aria-hidden="true">3.1.</strong> 模块系统</a></li><li><ol class="section"><li><a href="rust-2018/module-system/raw-identifiers.html"><strong aria-hidden="true">3.1.1.</strong> 原始标识符</a></li><li><a href="rust-2018/module-system/path-clarity.html"><strong aria-hidden="true">3.1.2.</strong> 路径清晰化</a></li><li><a href="rust-2018/module-system/more-visibility-modifiers.html"><strong aria-hidden="true">3.1.3.</strong> 更加可见的修饰符</a></li><li><a href="rust-2018/module-system/nested-imports-with-use.html"><strong aria-hidden="true">3.1.4.</strong> 用 use 进行导入嵌套</a></li></ol></li><li><a href="rust-2018/error-handling-and-panics/index.html"><strong aria-hidden="true">3.2.</strong> Error handling and panics</a></li><li><ol class="section"><li><a href="rust-2018/error-handling-and-panics/the-question-mark-operator-for-easier-error-handling.html"><strong aria-hidden="true">3.2.1.</strong> The ? operator for easier error handling</a></li><li><a href="rust-2018/error-handling-and-panics/question-mark-in-main-and-tests.html"><strong aria-hidden="true">3.2.2.</strong> ? in main and tests</a></li><li><a href="rust-2018/error-handling-and-panics/controlling-panics-with-std-panic.html"><strong aria-hidden="true">3.2.3.</strong> Controlling panics with std::panic</a></li><li><a href="rust-2018/error-handling-and-panics/aborting-on-panic.html"><strong aria-hidden="true">3.2.4.</strong> Aborting on panic</a></li></ol></li><li><a href="rust-2018/control-flow/index.html"><strong aria-hidden="true">3.3.</strong> Control flow</a></li><li><ol class="section"><li><a href="rust-2018/control-flow/loops-can-break-with-a-value.html"><strong aria-hidden="true">3.3.1.</strong> Loops can break with a value</a></li><li><a href="rust-2018/control-flow/async-await-for-easier-concurrency.html"><strong aria-hidden="true">3.3.2.</strong> async/await for easier concurrency</a></li></ol></li><li><a href="rust-2018/trait-system/index.html"><strong aria-hidden="true">3.4.</strong> Trait system</a></li><li><ol class="section"><li><a href="rust-2018/trait-system/impl-trait-for-returning-complex-types-with-ease.html"><strong aria-hidden="true">3.4.1.</strong> impl Trait for returning complex types with ease</a></li><li><a href="rust-2018/trait-system/dyn-trait-for-trait-objects.html"><strong aria-hidden="true">3.4.2.</strong> dyn Trait for trait objects</a></li><li><a href="rust-2018/trait-system/more-container-types-support-trait-objects.html"><strong aria-hidden="true">3.4.3.</strong> More container types support trait objects</a></li><li><a href="rust-2018/trait-system/associated-constants.html"><strong aria-hidden="true">3.4.4.</strong> Associated constants</a></li></ol></li><li><a href="rust-2018/slice-patterns.html"><strong aria-hidden="true">3.5.</strong> Slice patterns</a></li><li><a href="rust-2018/ownership-and-lifetimes/index.html"><strong aria-hidden="true">3.6.</strong> Ownership and lifetimes</a></li><li><ol class="section"><li><a href="rust-2018/ownership-and-lifetimes/default-match-bindings.html"><strong aria-hidden="true">3.6.1.</strong> Default match bindings</a></li><li><a href="rust-2018/ownership-and-lifetimes/the-anonymous-lifetime.html"><strong aria-hidden="true">3.6.2.</strong> '_, the anonymous lifetime</a></li><li><a href="rust-2018/ownership-and-lifetimes/lifetime-elision-in-impl.html"><strong aria-hidden="true">3.6.3.</strong> Lifetime elision in impl</a></li><li><a href="rust-2018/ownership-and-lifetimes/inference-in-structs.html"><strong aria-hidden="true">3.6.4.</strong> T: 'a inference in structs</a></li><li><a href="rust-2018/ownership-and-lifetimes/simpler-lifetimes-in-static-and-const.html"><strong aria-hidden="true">3.6.5.</strong> Simpler lifetimes in static and const</a></li></ol></li><li><a href="rust-2018/data-types/index.html"><strong aria-hidden="true">3.7.</strong> Data types</a></li><li><ol class="section"><li><a href="rust-2018/data-types/field-init-shorthand.html"><strong aria-hidden="true">3.7.1.</strong> Field init shorthand</a></li><li><a href="rust-2018/data-types/inclusive-ranges.html"><strong aria-hidden="true">3.7.2.</strong> ..= for inclusive ranges</a></li><li><a href="rust-2018/data-types/128-bit-integers.html"><strong aria-hidden="true">3.7.3.</strong> 128 bit integers</a></li><li><a href="rust-2018/data-types/operator-equals-are-now-implementable.html"><strong aria-hidden="true">3.7.4.</strong> &quot;Operator-equals&quot; are now implementable</a></li><li><a href="rust-2018/data-types/union-for-an-unsafe-form-of-enum.html"><strong aria-hidden="true">3.7.5.</strong> union for an unsafe form of enum</a></li><li><a href="rust-2018/data-types/choosing-alignment-with-the-repr-attribute.html"><strong aria-hidden="true">3.7.6.</strong> Choosing alignment with the repr attribute</a></li></ol></li><li><a href="rust-2018/simd-for-faster-computing.html"><strong aria-hidden="true">3.8.</strong> SIMD for faster computing</a></li><li><a href="rust-2018/macros/index.html"><strong aria-hidden="true">3.9.</strong> Macros</a></li><li><ol class="section"><li><a href="rust-2018/macros/custom-derive.html"><strong aria-hidden="true">3.9.1.</strong> Custom Derive</a></li><li><a href="rust-2018/macros/macro-changes.html"><strong aria-hidden="true">3.9.2.</strong> Macro changes</a></li></ol></li><li><a href="rust-2018/the-compiler/index.html"><strong aria-hidden="true">3.10.</strong> The compiler</a></li><li><ol class="section"><li><a href="rust-2018/the-compiler/improved-error-messages.html"><strong aria-hidden="true">3.10.1.</strong> Improved error messages</a></li><li><a href="rust-2018/the-compiler/incremental-compilation-for-faster-compiles.html"><strong aria-hidden="true">3.10.2.</strong> Incremental Compilation for faster compiles</a></li><li><a href="rust-2018/the-compiler/an-attribute-for-deprecation.html"><strong aria-hidden="true">3.10.3.</strong> An attribute for deprecation</a></li></ol></li><li><a href="rust-2018/rustup-for-managing-rust-versions.html"><strong aria-hidden="true">3.11.</strong> Rustup for managing Rust versions</a></li><li><a href="rust-2018/cargo-and-crates-io/index.html"><strong aria-hidden="true">3.12.</strong> Cargo and crates.io</a></li><li><ol class="section"><li><a href="rust-2018/cargo-and-crates-io/cargo-check-for-faster-checking.html"><strong aria-hidden="true">3.12.1.</strong> cargo check for faster checking</a></li><li><a href="rust-2018/cargo-and-crates-io/cargo-install-for-easy-installation-of-tools.html"><strong aria-hidden="true">3.12.2.</strong> cargo install for easy installation of tools</a></li><li><a href="rust-2018/cargo-and-crates-io/cargo-new-defaults-to-a-binary-project.html"><strong aria-hidden="true">3.12.3.</strong> cargo new defaults to a binary project</a></li><li><a href="rust-2018/cargo-and-crates-io/cargo-rustc-for-passing-arbitrary-flags-to-rustc.html"><strong aria-hidden="true">3.12.4.</strong> cargo rustc for passing arbitrary flags to rustc</a></li><li><a href="rust-2018/cargo-and-crates-io/cargo-workspaces-for-multi-package-projects.html"><strong aria-hidden="true">3.12.5.</strong> Cargo workspaces for multi-package projects</a></li><li><a href="rust-2018/cargo-and-crates-io/multi-file-examples.html"><strong aria-hidden="true">3.12.6.</strong> Multi-file examples</a></li><li><a href="rust-2018/cargo-and-crates-io/replacing-dependencies-with-patch.html"><strong aria-hidden="true">3.12.7.</strong> Replacing dependencies with patch</a></li><li><a href="rust-2018/cargo-and-crates-io/cargo-can-use-a-local-registry-replacement.html"><strong aria-hidden="true">3.12.8.</strong> Cargo can use a local registry replacement</a></li><li><a href="rust-2018/cargo-and-crates-io/crates-io-disallows-wildcard-dependencies.html"><strong aria-hidden="true">3.12.9.</strong> Crates.io disallows wildcard dependencies</a></li></ol></li><li><a href="rust-2018/documentation/index.html"><strong aria-hidden="true">3.13.</strong> Documentation</a></li><li><ol class="section"><li><a href="rust-2018/documentation/new-editions-of-the-book.html"><strong aria-hidden="true">3.13.1.</strong> New editions of the &quot;the book&quot;</a></li><li><a href="rust-2018/documentation/the-rust-bookshelf.html"><strong aria-hidden="true">3.13.2.</strong> The Rust Bookshelf</a></li><li><a href="rust-2018/documentation/the-rustonomicon.html"><strong aria-hidden="true">3.13.3.</strong> The Rustonomicon</a></li><li><a href="rust-2018/documentation/std-os-has-documentation-for-all-platforms.html"><strong aria-hidden="true">3.13.4.</strong> Full documentation for std::os</a></li></ol></li><li><a href="rust-2018/rustdoc/index.html"><strong aria-hidden="true">3.14.</strong> rustdoc</a></li><li><ol class="section"><li><a href="rust-2018/rustdoc/documentation-tests-can-now-compile-fail.html"><strong aria-hidden="true">3.14.1.</strong> Documentation tests can now compile-fail</a></li><li><a href="rust-2018/rustdoc/rustdoc-uses-commonmark.html"><strong aria-hidden="true">3.14.2.</strong> Rustdoc uses CommonMark</a></li></ol></li><li><a href="rust-2018/platform-and-target-support/index.html"><strong aria-hidden="true">3.15.</strong> Platform and target support</a></li><li><ol class="section"><li><a href="rust-2018/platform-and-target-support/libcore-for-low-level-rust.html"><strong aria-hidden="true">3.15.1.</strong> libcore for low-level Rust</a></li><li><a href="rust-2018/platform-and-target-support/webassembly-support.html"><strong aria-hidden="true">3.15.2.</strong> WebAssembly support</a></li><li><a href="rust-2018/platform-and-target-support/global-allocators.html"><strong aria-hidden="true">3.15.3.</strong> Global allocators</a></li><li><a href="rust-2018/platform-and-target-support/msvc-toolchain-support.html"><strong aria-hidden="true">3.15.4.</strong> MSVC toolchain support</a></li><li><a href="rust-2018/platform-and-target-support/musl-support-for-fully-static-binaries.html"><strong aria-hidden="true">3.15.5.</strong> MUSL support for fully static binaries</a></li><li><a href="rust-2018/platform-and-target-support/cdylib-crates-for-c-interoperability.html"><strong aria-hidden="true">3.15.6.</strong> cdylib crates for C interoperability</a></li></ol></li></ol></li><li><a href="unstable-feature-status.html"><strong aria-hidden="true">4.</strong> Unstable feature status</a></li></ol>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar" class="menu-bar">
                    <div id="menu-bar-sticky-container">
                        <div class="left-buttons">
                            <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                                <i class="fa fa-bars"></i>
                            </button>
                            <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                                <i class="fa fa-paint-brush"></i>
                            </button>
                            <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                                <li role="none"><button role="menuitem" class="theme" id="light">Light <span class="default">(default)</span></button></li>
                                <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                            </ul>
                            
                            <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                                <i class="fa fa-search"></i>
                            </button>
                            
                        </div>

                        <h1 class="menu-title">The Edition Guide</h1> 

                        <div class="right-buttons">
                            <a href="print.html" title="Print this book" aria-label="Print this book">
                                <i id="print-button" class="fa fa-print"></i>
                            </a>
                        </div>
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <a class="header" href="#a简介" id="a简介"><h1>简介</h1></a>
<p>欢迎来到 Rust 版本(Edition)使用指南！ &quot;Editions&quot; 是通过编写 Rust 代码来传达巨大改变的一种方式。</p>
<p>在指南中，我们将讨论：</p>
<ul>
<li>什么是版本(editions)</li>
<li>每个版本什么样</li>
<li>如何将你的代码从一个版本迁移到另一个版本</li>
</ul>
<p>请注意，标准库随每个Rust版本的增长而增长; 标准库中有<em>许多</em>添加的内容，本指南未对其进行说明。
只包含那些主要的变化，当然同时也有大量的中小型的改变也很棒。
您可能还想查看<a href="https://doc.rust-lang.org/std/">标准库文档</a>。</p>
<a class="header" href="#a什么是版本editions" id="a什么是版本editions"><h1>什么是版本(Editions)？</h1></a>
<p>Rust 六周发布一次新版本。这意味着用户可以获得不断的新功能。
这比其他语言的更新要快得多，但这也意味着每次更新都会更小。
一段时间之后，所有这些微小的变化都加进来了。
但是，从正式发布到正式发布，很难回头看看 <em>哇，在 Rust 1.10和 Rust 1.20之间，Rust已经发生了很大变化！</em></p>
<p>每隔两三年，我们将制作一个新 <em>版本</em> 的 Rust。
每个版本都将功能集成到一个清晰的包中，并提供全面更新的文档和工具。
新版本通过正常的发布流程发布。</p>
<p>这为不同的人提供不同的目的：</p>
<ul>
<li>
<p>对于活跃的 Rust 用户，它将增量更改集成到易于理解的包中。</p>
</li>
<li>
<p>对于非用户而言，它表明一些重大进步已经落地，这可能使 Rust 值得再看一眼。</p>
</li>
<li>
<p>对于那些开发 Rust 本身的人来说，它为整个项目提供了一个集结点。</p>
</li>
</ul>
<a class="header" href="#a兼容性" id="a兼容性"><h2>兼容性</h2></a>
<p>当编译器中出现新版本时，crates 必须明确选择使用它才能充分利用它。
此选择允许版本包含不兼容的更改，例如添加可能与代码中的标识符冲突的新关键字，或将警告转换为错误。
Rust 编译器将支持编译器发布之前存在的所有版本，并且可以将任何受支持版本的 crates 链接在一起。
版本更改仅影响编译器最初解析代码的方式。
因此，如果您正在使用 Rust 2015，并且您的某个依赖项使用 Rust 2018，那么一切正常。相反的情况也适用。</p>
<p>需要明确的是：大多数功能都适用于所有版本。随着新的稳定版本的发布，使用任何版本的 Rust 的人将继续看到改进。
但是，在某些情况下，主要是在添加新关键字时，但有时由于其他原因，可能会有新功能仅在以后的版本中提供。如果要利用此类功能，则只需升级。</p>
<a class="header" href="#a试一下2018版本" id="a试一下2018版本"><h2>试一下2018版本</h2></a>
<p>在撰写本文时，有两个版本：2015和2018。2015是现在的 Rust版本; Rust 2018将于今年晚些时候发布。
要从2015版本过渡到2018版本，您需要开始使用<a href="transitioning-your-code-to-a-new-edition.html">迁移说明</a>。</p>
<a class="header" href="#a迁移你的代码到新版本" id="a迁移你的代码到新版本"><h1>迁移你的代码到新版本</h1></a>
<p>新版本可能会改变您编写 Rust 的方式 - 它们会添加新的语法，语言和库功能，但也会删除功能。
例如，<code>try</code>，<code>async</code>和<code>await</code>是 Rust 2018 中的关键字，但不在 Rust 2015中。
尽管如此，我们试图尽可能顺利地迁移到新版本。
如果很难将您的 crates 升级到新版本，那么这可能是一个 bug 。如果您遇到困难，那么应该向 Rust 提交一个 bug。</p>
<p>版本之间的迁移是围绕编译器标签(lints)构建的。从根本上说，这个过程是这样的：</p>
<ul>
<li>打开 lints 以指示代码与新版本不兼容的位置</li>
<li>在没有警告的情况下编译代码。</li>
<li>选择加入新版本，代码应该编译。
*（可选）在新版本中启用有关 <em>idiomatic</em> 代码的 lints。</li>
</ul>
<p>幸运的是，我们一直致力于 Cargo 帮助完成这一过程，最终推出了一个新的内置子命令 <code>cargo fix</code>。
它可以从编译器中获取建议并自动重新编写代码以符合新功能和习惯用法，从而大大减少手动修复所需的警告数量！</p>
<blockquote>
<p><code>cargo fix</code> 仍然很早期，而且非常重要。但它已经适用于基础部分！我们正在努力使其变得更好，更强大，但暂时不必使用。</p>
</blockquote>
<a class="header" href="#a预览期" id="a预览期"><h2>预览期</h2></a>
<p>在发布版本之前，它将有一个“预览”阶段，让您可以在发布之前在 nightly 的 Rust 中试用新版本。
目前 Rust 2018 正处于预览阶段，因此，您需要采取额外的步骤来选择加入。
将此功能标志添加到您的<code>lib.rs</code>或<code>main.rs</code>以及任何示例中。如果你有一个项目的<code>examples</code>目录：</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#![feature(rust_2018_preview)]
#fn main() {
#}</code></pre></pre>
<p>这将启用 <a href="../unstable-feature-status.html">特性状态</a> 页面中列出的不稳定功能。请注意，某些功能需要最小的 Rust 2018，这些功能需要 Cargo.toml 拥有更改权限才能启用（在下面的部分中描述）。
另请注意，在预览可用期间，我们可能会继续使用此标志来添加/启用新功能！</p>
<p>对于 Rust 2018 预览版2中，我们还测试了<a href="../rust-2018/module-system/path-clarity.html">新模块路径变体</a>，“统一路径”，我们想要获得进一步测试和反馈。
请尝试将以下内容添加到<code>lib.rs</code>或<code>main.rs</code>中：</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#![feature(rust_2018_preview, uniform_paths)]
#fn main() {
#}</code></pre></pre>
<p>Rust 2018 的发布时候将会选择两个模块路径变体中的一个，并放弃另一个。
The release of Rust 2018 will stabilize one of the two module path variants and drop the other.</p>
<a class="header" href="#a修复版本兼容性警告" id="a修复版本兼容性警告"><h2>修复版本兼容性警告</h2></a>
<p>接下来是启用有关与新 2018 版本 不兼容的代码的编译器警告。 这是方便 <code>cargo fix</code> 这个工具进入图片的地方。 要为项目启用兼容性lints，请运行：</p>
<pre><code class="language-shell">$ cargo fix --edition
</code></pre>
<p>如果 nightly 不是你的默认选择的话，你需要运行下面的这个命令：</p>
<pre><code class="language-shell">$ cargo +nightly fix --edition
</code></pre>
<p>这将指示 Cargo 编译项目中的所有目标（库，二进制文件，测试等），同时启用所有 Cargo 功能并为2018版本做好准备。
Cargo 可能会自动修复一些文件，并在其发生时通知您。 请注意，这不会启用任何新的 Rust 2018 功能; 它只能确保您的代码与 Rust 2018 兼容。</p>
<p>如果Cargo无法自动修复所有内容，它将打印出剩余的警告。继续运行上述命令，直到所有警告都已解决。</p>
<p>你可以获取更多 <code>cargo fix</code> 信息，运行：</p>
<pre><code class="language-shell">$ cargo fix --help
</code></pre>
<a class="header" href="#a切换到下一个版本" id="a切换到下一个版本"><h2>切换到下一个版本</h2></a>
<p>一旦您对这些更改感到满意，就可以使用新版本了。 将其添加到您的 <code>Cargo.toml</code>：</p>
<pre><code class="language-toml">cargo-features = [&quot;edition&quot;]

[package]
edition = '2018'
</code></pre>
<p>那个 <code>cargo-features</code> 行应该排在最前面; <code>edition</code> 进入 <code>[package]</code> 部分。
如上所述，现在这是 Cargo 的 nightly 特征，因此您需要启用它才能使其工作。</p>
<p>此时，您的项目应该使用常规的<code>cargo build</code>进行编译。 如果没有，这是一个错误！ 请<a href="https://github.com/rust-lang/rust/issues/new">提交问题</a>。</p>
<a class="header" href="#a在新版本中编写惯用代码" id="a在新版本中编写惯用代码"><h2>在新版本中编写惯用代码</h2></a>
<p>你的 crate 现在已经进入了2018版的 Rust，恭喜！ 回想一下，Rust 中的 Editions 表示随着时间的推移，习惯用语的转变。
虽然很多旧代码将继续编译，但今天可能会用不同的习惯用语编写。</p>
<p>您可以采取的可选的后续步骤是将代码更新为新版本中的惯用语。
这是通过一组不同的“习惯用语lints”完成的。 就像之前我们使用 <code>cargo fix</code> 来推动这个过程一样：</p>
<pre><code class="language-shell">$ cargo fix --edition-idioms
</code></pre>
<p>与之前一样，这是一个 <em>简单</em> 的步骤。
在这里 <code>cargo fix</code> 将自动修复任何可能的lint，所以你只会得到 <code>cargo fix</code> 无法修复的情况下的警告。
如果您发现难以完成警告，那就是一个错误！</p>
<p>一旦你用这个命令警告没有了，你就可以继续了。</p>
<blockquote>
<p><code>--edition-idioms</code> 标志仅适用于“当前 crate”，如果你想在工作空间运行它是必要的，使用 <code>RUSTFLAGS</code> 的解决方法，以便在所有工作区中执行它。</p>
<pre><code class="language-shell">$ RUSTFLAGS='-Wrust_2018_idioms' cargo fix --all
</code></pre>
</blockquote>
<p>享受新版本吧！</p>
<a class="header" href="#rust-2015" id="rust-2015"><h1>Rust 2015</h1></a>
<p>Rust 2015 的主题是“稳定性”。 它从1.0版本开始，是“默认版”。
该版本系统于2017年底构思，但 Rust 1.0 于2015年5月发布。因此，2015年是您未指定任何特定版本时获得的版本，出于向后兼容性原因。</p>
<p>“稳定性”是 Rust 2015 的主题，因为1.0标志着 Rust 开发的巨大变化。 在 Rust 1.0 之前，Rust 每天都在变化。 这使得在 Rust 中编写大型软件变得非常困难，并且难以学习。
随着 Rust 1.0 和 Rust 2015 的发布，我们致力于向后兼容，确保为人们构建项目奠定坚实的基础。</p>
<p>由于它是默认版本，因此无法将代码移植到 Rust 2015; 它 <em>就是</em>。 你将从 2015 开始 <em>过渡</em>，但从未真正 <em>到</em> 2015版。因此，没有什么可说的了！</p>
<a class="header" href="#rust-2018" id="rust-2018"><h1>Rust 2018</h1></a>
<p>该版本系统是为 Rust 2018 的发布而创建的. Rust 2018 的主题是<em>生产力</em>。
Rust 2018 通过新功能，在某些情况下更简单的语法，更智能的借用检查器以及许多其他东西来改进 Rust 2015。
这些都是为了提高生产力目标。 Rust 2015 是一个基础; Rust 2018 使粗糙边缘平滑，使编写代码更简单，更容易，并消除了一些不一致性。</p>
<a class="header" href="#a模块系统" id="a模块系统"><h1>模块系统</h1></a>
<p>在本指南的这一章中，我们将讨论模块系统的一些变化。
其中最值得注意的是 <a href="path-clarity.html">路径清晰度变化</a>。</p>
<a class="header" href="#a原始标识符" id="a原始标识符"><h1>原始标识符</h1></a>
<p><img src="https://img.shields.io/badge/Minimum%20Rust%20Version-nightly-red.svg" alt="Minimum Rust version: nightly" /></p>
<p>与许多编程语言一样，Rust 具有“关键字”的概念。
这些标识符对语言有意义，因此你不能在变量名，函数名和其他位置使用它们。
原始标识符允许你使用通常不允许的关键字。</p>
<p>举个例子，<code>match</code> 是一个关键字。如果你试图编译这个方法：</p>
<pre><code class="language-rust ignore">fn match(needle: &amp;str, haystack: &amp;str) -&gt; bool {
    haystack.contains(needle)
}
</code></pre>
<p>你将得到以下错误：</p>
<pre><code class="language-text">error: expected identifier, found keyword `match`
 --&gt; src/main.rs:4:4
  |
4 | fn match(needle: &amp;str, haystack: &amp;str) -&gt; bool {
  |    ^^^^^ expected identifier, found keyword
</code></pre>
<p>你可以使用原始标识符来实现:</p>
<pre><pre class="playpen"><code class="language-rust">#![feature(rust_2018_preview)]
#![feature(raw_identifiers)]

fn r#match(needle: &amp;str, haystack: &amp;str) -&gt; bool {
    haystack.contains(needle)
}

fn main() {
    assert!(r#match(&quot;foo&quot;, &quot;foobar&quot;));
}
</code></pre></pre>
<p>注意 <code>r#</code> 不仅在定义的时候有，在调用的时候也得有。</p>
<a class="header" href="#a更多的细节" id="a更多的细节"><h2>更多的细节</h2></a>
<p>此功能还是有一些用处的，但主要动机是版本间的情况。
例如，<code>try</code> 不是2015版的关键字，而是2018版的。
因此，如果你有一个用 Rust 2015 编写并具有 <code>try</code> 函数的库，要在 Rust 2018 中调用它，你需要使用原始标识符。</p>
<a class="header" href="#a新的关键字" id="a新的关键字"><h2>新的关键字</h2></a>
<p>2018 中新定义的关键字:</p>
<a class="header" href="#async-and-await" id="async-and-await"><h3><code>async</code> and <code>await</code></h3></a>
<p>这里, 保留 <code>async</code> 用来实现 <code>async fn</code> 或者 <code>async ||</code> 闭包 和 <code>async { .. }</code> 块。
同时， 保留 <code>await</code> 用来保持 <code>await!(expr)</code> 这种语法是一个开放的选项。有关详细信息，请参阅 <a href="https://github.com/rust-lang/rfcs/blob/master/text/2394-async_await.md#final-syntax-for-the-await-expression">RFC 2394</a>。</p>
<a class="header" href="#try" id="try"><h3><code>try</code></h3></a>
<p><code>do catch { .. }</code> 块已经被重命名为 <code>try { .. }</code> 并已经得到支持, 关键字 <code>try</code> 在2018版中将被保留. 有关详细信息，请参阅 <a href="https://github.com/rust-lang/rfcs/pull/2388">RFC 2388</a>。</p>
<a class="header" href="#a路径清晰化" id="a路径清晰化"><h1>路径清晰化</h1></a>
<p><img src="https://img.shields.io/badge/Minimum%20Rust%20Version-nightly-red.svg" alt="Minimum Rust version: nightly" /></p>
<p>对于刚接触 Rust 的人来说，模块系统通常是最困难的事情之一。
当然，每个人掌握东西的时间都不同，但是有一个根本原因，导致了为什么对许多人来说模块系统如此混乱：
尽管模块系统有了简单而一致的定义规则，但它们给人的感觉可能不一致，甚至是违反直觉的，神秘的。</p>
<p>因此，Rust 2018 引入了一些新的模块系统功能，它们将<em>简单化</em>模块系统，使其更加清晰。</p>
<p>注意：在2018版预览期间，正在考虑的模块系统有两种变体，“统一路径(uniform paths)”变体和“锚定使用路径(anchored use paths)”变体。
这些变化大多数是适用于两种变体的; 两个变体部分也列出了两者之间的差异。
我们鼓励使用预览2版本的用户，引入新的“统一路径”变体。Rust 2018 的稳定发布时，将只会选择其一。</p>
<p>要使用新的“统一路径”变体测试 Rust 2018 ，请将 <code>#![feature(rust_2018_preview, uniform_paths)]</code> 放在 <code>lib.rs</code> 或 <code>main.rs</code> 的顶部。</p>
<p>这是一个简短的总结：</p>
<ul>
<li><code>extern crate</code> 不再需要。</li>
<li><code>crate</code> 关键字指的是当前的 crate。</li>
<li>统一路径变体： 路径在 <code>use</code> 声明和其他代码中统一工作。路径在顶级模块和子模块中统一工作。任何路径都可以以crate开头，包括 <code>crate</code> ，<code>super</code> 或 <code>self</code> ，或者具有相对于当前模块的本地名称。</li>
<li>锚定使用路径变量： <code>use</code> 声明中的路径始终以包名称开头，或者以 <code>crate</code> ， <code>super</code> 或 <code>self</code> 开头。 除了 <code>use</code> 声明之外的代码中的路径也可以从相对于当前模块的名称开始。</li>
<li><code>foo.rs</code> 和 <code>foo /</code> 子目录可以共存; 将子模块放在子目录中时不再需要<code>mod.rs</code>。</li>
</ul>
<p>这样看起来就像是新的规则，但现在心理模型整体上大大简化了。 请阅读以获得更多详情！</p>
<a class="header" href="#a更多的细节-1" id="a更多的细节-1"><h2>更多的细节</h2></a>
<p>让我们依次讨论每个新功能。</p>
<a class="header" href="#a不再需要-extern-crate" id="a不再需要-extern-crate"><h3>不再需要 <code>extern crate</code></h3></a>
<p>这个非常简单：您不再需要编写 <code>extern crate</code> 来将crate导入到您的项目中。 之前：</p>
<pre><code class="language-rust ignore">// Rust 2015

extern crate futures;

mod submodule {
    use futures::Future;
}
</code></pre>
<p>现在:</p>
<pre><code class="language-rust ignore">// Rust 2018

mod submodule {
    use futures::Future;
}
</code></pre>
<p>现在，要为项目添加一个新的包，你可以将它添加到你的 <code>Cargo.toml</code>，然后没有第二步。
如果你没有使用Cargo，你必须通过 <code>--extern</code> 标志给 <code>rustc</code> 提供外部crate的位置，然后继续做其他的事前吧。</p>
<p><code>extern crate</code>的另一个用途是导入宏; 那也不再需要了。 查看<a href="../macros/macro-changes.html">宏章节</a>以获取更多信息。</p>
<a class="header" href="#crate-指当前crate" id="crate-指当前crate"><h3><code>crate</code> 指当前crate.</h3></a>
<p>在 <code>use</code> 声明和其他代码中，您可以使用 <code>crate::</code> 前缀来引用当前包的根。
例如，<code>crate::foo::bar</code> 将始终引用模块 <code>foo</code> 中的名称 <code>bar</code>，来自同一个crate中的任何其他位置。</p>
<p>前缀 <code>::</code> 以前称为crate root或外部crate; 它现在毫无疑问的是指外部crate。
例如，<code>::foo::bar</code>总是指外部crate中 <code>foo</code> 中的 <code>bar</code>。</p>
<a class="header" href="#a统一路径变体" id="a统一路径变体"><h3>统一路径变体</h3></a>
<p>与 Rust 2015 相比，Rust 2018 的统一路径变体简化并统一了路径处理。
在 Rust 2015 中，路径在 <code>use</code> 声明中的工作方式与在其他地方的工作方式不同。
特别地，<code>use</code> 声明中的路径总是从包根开始，而其他代码中的路径隐含地从当前模块开始。
这些差异在顶级模块中没有任何影响，这意味着在处理足够大的子模块项目之前，所有内容都会显得简单明了。</p>
<p>在 Rust 2018 的统一路径变体中，<code>use</code> 声明和其他代码中的路径始终以相同的方式工作，无论是在顶级模块还是在任何子模块中。
您始终可以使用当前模块的相对路径，从外部包名称开始的路径，或以 <code>crate</code> ， <code>super</code> 或 <code>self</code> 开头的路径。</p>
<p>代码长这样：</p>
<pre><code class="language-rust ignore">// Rust 2015

extern crate futures;

use futures::Future;

mod foo {
    pub struct Bar;
}

use foo::Bar;

fn my_poll() -&gt; futures::Poll { ... }

enum SomeEnum {
    V1(usize),
    V2(String),
}

fn func() {
    let five = std::sync::Arc::new(5);
    use SomeEnum::*;
    match ... {
        V1(i) =&gt; { ... }
        V2(s) =&gt; { ... }
    }
}
</code></pre>
<p>在 Rust 2018 中看起来完全一样，除了删除 <code>extern crate</code> 行：</p>
<pre><code class="language-rust ignore">// Rust 2018 (uniform paths variant)

use futures::Future;

mod foo {
    pub struct Bar;
}

use foo::Bar;

fn my_poll() -&gt; futures::Poll { ... }

enum SomeEnum {
    V1(usize),
    V2(String),
}

fn func() {
    let five = std::sync::Arc::new(5);
    use SomeEnum::*;
    match ... {
        V1(i) =&gt; { ... }
        V2(s) =&gt; { ... }
    }
}
</code></pre>
<p>但是，使用 Rust 2018，相同的代码也可以在子模块中完全不修改：</p>
<pre><code class="language-rust ignore">// Rust 2018 (uniform paths variant)

mod submodule {
    use futures::Future;

    mod foo {
        pub struct Bar;
    }

    use foo::Bar;

    fn my_poll() -&gt; futures::Poll { ... }

    enum SomeEnum {
        V1(usize),
        V2(String),
    }

    fn func() {
        let five = std::sync::Arc::new(5);
        use SomeEnum::*;
        match ... {
            V1(i) =&gt; { ... }
            V2(s) =&gt; { ... }
        }
    }
}
</code></pre>
<p>这样可以轻松地在项目中移动代码，并避免为引入多模块项目增加额外的复杂性。</p>
<p>如果路径不明确，例如，如果您有外部包和本地模块或具有相同名称的项目，您将收到错误，并且您需要重命名其中一个冲突名称或明确消除路径歧义。
要明确消除路径歧义，请使用 <code>::name</code> 作为外部包名，或使用 <code>self::name</code> 作为本地模块或项目。</p>
<a class="header" href="#a锚定使用路径" id="a锚定使用路径"><h3>锚定使用路径</h3></a>
<p>在 Rust 2018 的锚定使用路径变体中，<code>use</code> 声明 <em>必须</em> 必须以包名开头，开头包括 <code>crate</code>， <code>self</code> 或 <code>super</code>。</p>
<p>以前代码长这样：</p>
<pre><code class="language-rust ignore">// Rust 2015

extern crate futures;

use futures::Future;

mod foo {
    pub struct Bar;
}

use foo::Bar;
</code></pre>
<p>现在长这样:</p>
<pre><code class="language-rust ignore">// Rust 2018 (anchored use paths variant)

// 'futures' is the name of a crate
use futures::Future;

mod foo {
    pub struct Bar;
}

// 'crate' means the current crate
use crate::foo::Bar;
</code></pre>
<p>此外，所有这些路径形式也可以在 <code>use</code> 声明之外使用，这消除了许多混淆的来源。 在Rust 2015中考虑以下代码：</p>
<pre><code class="language-rust ignore">// Rust 2015

extern crate futures;

mod submodule {
    // this works!
    use futures::Future;

    // so why doesn't this work?
    fn my_poll() -&gt; futures::Poll { ... }
}

fn main() {
    // this works
    let five = std::sync::Arc::new(5);
}

mod submodule {
    fn function() {
        // ... so why doesn't this work
        let five = std::sync::Arc::new(5);
    }
}
</code></pre>
<p>在 <code>futures</code> 示例中，<code>my_poll</code> 函数签名不正确，因为 <code>submodule</code> 不包含名为 <code>futures</code> 的项目; 也就是说，这条路径被认为是相对的。
但是因为 <code>use</code> 是锚定的，<code>use futures::</code> 即使单独的 <code>futures::</code> 也不行！
使用 <code>std</code> 它可能会更加令人困惑，因为你从来没有写过 <code>extern crate std;</code> 行。
那么为什么它在 <code>main</code> 中工作但不在子模块中工作？
同样的事情：它是一个相对路径，因为它不在 <code>use</code> 声明中。
<code>extern crate std;</code>被插入到crate root中，所以它在 <code>main</code> 中很好，但它根本不存在于子模块中。</p>
<p>让我们来看看这种变化如何影响：</p>
<pre><code class="language-rust ignore">// Rust 2018 (anchored use paths variant)

// no more `extern crate futures;`

mod submodule {
    // 'futures' is the name of a crate, so this is anchored and works
    use futures::Future;

    // 'futures' is the name of a crate, so this is anchored and works
    fn my_poll() -&gt; futures::Poll { ... }
}

fn main() {
    // 'std' is the name of a crate, so this is anchored and works
    let five = std::sync::Arc::new(5);
}

mod submodule {
    fn function() {
        // 'std' is the name of a crate, so this is anchored and works
        let five = std::sync::Arc::new(5);
    }
}
</code></pre>
<p>更加的直截了当。</p>
<a class="header" href="#a不再需要-modrs" id="a不再需要-modrs"><h3>不再需要 <code>mod.rs</code></h3></a>
<p>在 Rust 2015 中，子模块如下：</p>
<pre><code class="language-rust ignore">mod foo;
</code></pre>
<p>它可以是 <code>foo.rs</code> 或者 <code>foo/mod.rs</code>。如果是一个子模块，那么它 <em>必须</em> 有一个 <code>foo/mod.rs</code>。 这样的化， <code>bar</code> 存在于子模块 <code>foo</code> 中，将表现为 <code>foo/bar.rs</code>。</p>
<p>在 Rust 2018 中，<code>mod.rs</code> 不再需要，<code>foo.rs</code>仅仅表示 <code>foo.rs</code>，子模块仍然是 <code>foo/bar.rs</code>。
这消除了特殊名称，如果你在编辑器中打开了一堆文件，你可以清楚地看到它们的名字，而不是有一堆名为 <code>mod.rs</code> 的标签。</p>
<a class="header" href="#a更加可见的修饰符" id="a更加可见的修饰符"><h1>更加可见的修饰符</h1></a>
<p><img src="https://img.shields.io/badge/Minimum%20Rust%20Version-1.18-brightgreen.svg" alt="Minimum Rust version: 1.18" /></p>
<p>您可以使用 <code>pub</code> 关键字将某些内容作为模块公共接口的一部分。 但此外，还有一些新形式：</p>
<pre><code class="language-rust ignore">pub(crate) struct Foo;

pub(in a::b::c) struct Bar;
</code></pre>
<p>第一种形式使 <code>Foo</code> 结构公开在整个crate中，但不是外部的。
第二种形式是类似的，只在另一种模块 <code>a::b::c</code> 中，<code>Bar</code>是公开的。</p>
<a class="header" href="#a用-use-进行导入嵌套" id="a用-use-进行导入嵌套"><h1>用 <code>use</code> 进行导入嵌套</h1></a>
<p><img src="https://img.shields.io/badge/Minimum%20Rust%20Version-1.25-brightgreen.svg" alt="Minimum Rust version: 1.25" /></p>
<p>在 Rust 中： 嵌套导入中添加了一种编写 <code>use</code> 语句的新方法。
如果您曾编写过这样的一组导入：</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use std::fs::File;
use std::io::Read;
use std::path::{Path, PathBuf};
#}</code></pre></pre>
<p>可以这样写了：</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# mod foo {
// on one line
use std::{fs::File, io::Read, path::{Path, PathBuf}};
# }

# mod bar {
// with some more breathing room
use std::{
    fs::File,
    io::Read,
    path::{
        Path,
        PathBuf
    }
};
# }
#}</code></pre></pre>
<p>这可以减少一些重复，并使事情更清晰。</p>
<a class="header" href="#error-handling-and-panics" id="error-handling-and-panics"><h1>Error handling and Panics</h1></a>
<p>In this chapter of the guide, we discuss a few improvements to error handling
in Rust. The most notable of these is <a href="the-question-mark-operator-for-easier-error-handling.html">the introduction of the <code>?</code> operator</a>.</p>
<a class="header" href="#the--operator-for-easier-error-handling" id="the--operator-for-easier-error-handling"><h1>The <code>?</code> operator for easier error handling</h1></a>
<p><img src="https://img.shields.io/badge/Minimum%20Rust%20Version-1.13-brightgreen.svg" alt="Minimum Rust version: 1.13" /> for <code>Result&lt;T, E&gt;</code></p>
<p><img src="https://img.shields.io/badge/Minimum%20Rust%20Version-1.22-brightgreen.svg" alt="Minimum Rust version: 1.22" /> for <code>Option&lt;T&gt;</code></p>
<p><img src="https://img.shields.io/badge/Minimum%20Rust%20Version-1.26-brightgreen.svg" alt="Minimum Rust version: 1.26" /> for using <code>?</code> in <code>main</code> and tests</p>
<p>Rust has gained a new operator, <code>?</code>, that makes error handling more pleasant
by reducing the visual noise involved. It does this by solving one simple
problem. To illustrate, imagine we had some code to read some data from a
file:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# use std::{io::{self, prelude::*}, fs::File};
fn read_username_from_file() -&gt; Result&lt;String, io::Error&gt; {
    let f = File::open(&quot;username.txt&quot;);

    let mut f = match f {
        Ok(file) =&gt; file,
        Err(e) =&gt; return Err(e),
    };

    let mut s = String::new();

    match f.read_to_string(&amp;mut s) {
        Ok(_) =&gt; Ok(s),
        Err(e) =&gt; Err(e),
    }
}
#}</code></pre></pre>
<blockquote>
<p>Note: this code could be made simpler with a single call to
<a href="https://doc.rust-lang.org/stable/std/fs/fn.read_to_string.html"><code>std::fs::read_to_string</code></a>,
but we're writing it all out manually here to have an example with mutliple
errors.</p>
</blockquote>
<p>This code has two paths that can fail, opening the file and reading the data
from it. If either of these fail to work, we'd like to return an error from
<code>read_username_from_file</code>. Doing so involves <code>match</code>ing on the result of the
I/O operations. In simple cases like this though, where we are only
propagating errors up the call stack, the matching is just boilerplate -
seeing it written out, in the same pattern every time, doesn't provide the
reader with a great deal of useful information.</p>
<p>With <code>?</code>, the above code looks like this:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# use std::{io::{self, prelude::*}, fs::File};
fn read_username_from_file() -&gt; Result&lt;String, io::Error&gt; {
    let mut f = File::open(&quot;username.txt&quot;)?;
    let mut s = String::new();

    f.read_to_string(&amp;mut s)?;

    Ok(s)
}
#}</code></pre></pre>
<p>The <code>?</code> is shorthand for the entire match statements we wrote earlier. In
other words, <code>?</code> applies to a <code>Result</code> value, and if it was an <code>Ok</code>, it
unwraps it and gives the inner value. If it was an <code>Err</code>, it returns from the
function you're currently in. Visually, it is much more straightforward.
Instead of an entire match statement, now we are just using the single &quot;?&quot;
character to indicate that here we are handling errors in the standard way,
by passing them up the call stack.</p>
<p>Seasoned Rustaceans may recognize that this is the same as the <code>try!</code> macro
that's been available since Rust <code>1.0</code>. And indeed, they are the same.
Previously, <code>read_username_from_file</code> could have been implemented like this:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# use std::{io::{self, prelude::*}, fs::File};
fn read_username_from_file() -&gt; Result&lt;String, io::Error&gt; {
    let mut f = try!(File::open(&quot;username.txt&quot;));
    let mut s = String::new();

    try!(f.read_to_string(&amp;mut s));

    Ok(s)
}
#}</code></pre></pre>
<p>So why extend the language when we already have a macro? There are multiple
reasons. First, <code>try!</code> has proved to be extremely useful, and is used often
in idiomatic Rust. It is used so often that we think it's worth having a
sweet syntax. This sort of evolution is one of the great advantages of a
powerful macro system: speculative extensions to the language syntax can be
prototyped and iterated on without modifying the language itself, and in
return, macros that turn out to be especially useful can indicate missing
language features. This evolution, from <code>try!</code> to <code>?</code> is a great example.</p>
<p>One of the reasons <code>try!</code> needs a sweeter syntax is that it is quite
unattractive when multiple invocations of <code>try!</code> are used in succession.
Consider:</p>
<pre><code class="language-rust ignore">try!(try!(try!(foo()).bar()).baz())
</code></pre>
<p>as opposed to</p>
<pre><code class="language-rust ignore">foo()?.bar()?.baz()?
</code></pre>
<p>The first is quite difficult to scan visually, and each layer of error
handling prefixes the expression with an additional call to <code>try!</code>. This
brings undue attention to the trivial error propagation, obscuring the main
code path, in this example the calls to <code>foo</code>, <code>bar</code> and <code>baz</code>. This sort of
method chaining with error handling occurs in situations like the builder
pattern.</p>
<p>Finally, the dedicated syntax will make it easier in the future to produce
nicer error messages tailored specifically to <code>?</code>, whereas it is difficult to
produce nice errors for macro-expanded code generally.</p>
<p>You can use <code>?</code> with <code>Result&lt;T, E&gt;</code>s, but also with <code>Option&lt;T&gt;</code>. In that
case, <code>?</code> will return a value for <code>Some(T)</code> and return <code>None</code> for <code>None</code>. One
current restriction is that you cannot use <code>?</code> for both in the same function,
as the return type needs to match the type you use <code>?</code> on. In the future,
this restriction will be lifed.</p>
<a class="header" href="#a-in-main-and-tests" id="a-in-main-and-tests"><h2><code>?</code> in <code>main</code> and tests</h2></a>
<p>Rust's error handling revolves around returning <code>Result&lt;T, E&gt;</code> and using <code>?</code>
to propagate errors. For those who write many small programs and, hopefully,
many tests, one common paper cut has been mixing entry points such as <code>main</code>
and <code>#[test]</code>s with error handling.</p>
<p>As an example, you might have tried to write:</p>
<pre><code class="language-rust ignore">use std::fs::File;

fn main() {
    let f = File::open(&quot;bar.txt&quot;)?;
}
</code></pre>
<p>Since <code>?</code> works by propagating the <code>Result</code> with an early return to the
enclosing function, the snippet above does not work, and results today
in the following error:</p>
<pre><code class="language-rust ignore">error[E0277]: the `?` operator can only be used in a function that returns `Result`
              or `Option` (or another type that implements `std::ops::Try`)
 --&gt; src/main.rs:5:13
  |
5 |     let f = File::open(&quot;bar.txt&quot;)?;
  |             ^^^^^^^^^^^^^^^^^^^^^^ cannot use the `?` operator in a function that returns `()`
  |
  = help: the trait `std::ops::Try` is not implemented for `()`
  = note: required by `std::ops::Try::from_error`
</code></pre>
<p>To solve this problem in Rust 2015, you might have written something like:</p>
<pre><pre class="playpen"><code class="language-rust">// Rust 2015

# use std::process;
# use std::error::Error;

fn run() -&gt; Result&lt;(), Box&lt;Error&gt;&gt; {
    // real logic..
    Ok(())
}

fn main() {
    if let Err(e) = run() {
        println!(&quot;Application error: {}&quot;, e);
        process::exit(1);
    }
}
</code></pre></pre>
<p>However, in this case, the <code>run</code> function has all the interesting logic and
<code>main</code> is just boilerplate. The problem is even worse for <code>#[test]</code>s, since
there tend to be a lot more of them.</p>
<p>In Rust 2018 you can instead let your <code>#[test]</code>s and <code>main</code> functions return
a <code>Result</code>:</p>
<pre><pre class="playpen"><code class="language-rust no_run">// Rust 2018

use std::fs::File;

fn main() -&gt; Result&lt;(), std::io::Error&gt; {
    let f = File::open(&quot;bar.txt&quot;)?;

    Ok(())
}
</code></pre></pre>
<p>In this case, if say the file doesn't exist and there is an <code>Err(err)</code> somewhere,
then <code>main</code> will exit with an error code (not <code>0</code>) and print out a <code>Debug</code>
representation of <code>err</code>.</p>
<a class="header" href="#more-details" id="more-details"><h2>More details</h2></a>
<p>Getting <code>-&gt; Result&lt;..&gt;</code> to work in the context of <code>main</code> and <code>#[test]</code>s is not
magic. It is all backed up by a <code>Termination</code> trait which all valid return
types of <code>main</code> and testing functions must implement. The trait is defined as:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
pub trait Termination {
    fn report(self) -&gt; i32;
}
#}</code></pre></pre>
<p>When setting up the entry point for your application, the compiler will use this
trait and call <code>.report()</code> on the <code>Result</code> of the <code>main</code> function you have written.</p>
<p>Two simplified example implementations of this trait for <code>Result</code> and <code>()</code> are:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# #![feature(process_exitcode_placeholder, termination_trait_lib)]
# use std::process::ExitCode;
# use std::fmt;
#
# pub trait Termination { fn report(self) -&gt; i32; }

impl Termination for () {
    fn report(self) -&gt; i32 {
        # use std::process::Termination;
        ExitCode::SUCCESS.report()
    }
}

impl&lt;E: fmt::Debug&gt; Termination for Result&lt;(), E&gt; {
    fn report(self) -&gt; i32 {
        match self {
            Ok(()) =&gt; ().report(),
            Err(err) =&gt; {
                eprintln!(&quot;Error: {:?}&quot;, err);
                # use std::process::Termination;
                ExitCode::FAILURE.report()
            }
        }
    }
}
#}</code></pre></pre>
<p>As you can see in the case of <code>()</code>, a success code is simply returned.
In the case of <code>Result</code>, the success case delegates to the implementation for
<code>()</code> but prints out an error message and a failure exit code on <code>Err(..)</code>.</p>
<p>To learn more about the finer details, consult either <a href="https://github.com/rust-lang/rust/issues/43301">the tracking issue</a> or <a href="https://github.com/rust-lang/rfcs/blob/master/text/1937-ques-in-main.md">the RFC</a>.</p>
<a class="header" href="#a-in-main-and-tests-1" id="a-in-main-and-tests-1"><h1><code>?</code> in <code>main</code> and tests</h1></a>
<p><img src="https://img.shields.io/badge/Minimum%20Rust%20Version-1.26-brightgreen.svg" alt="Minimum Rust version: 1.26" /></p>
<p>Rust's error handling revolves around returning <code>Result&lt;T, E&gt;</code> and using <code>?</code>
to propagate errors. For those who write many small programs and, hopefully,
many tests, one common paper cut has been mixing entry points such as <code>main</code>
and <code>#[test]</code>s with error handling.</p>
<p>As an example, you might have tried to write:</p>
<pre><code class="language-rust ignore">use std::fs::File;

fn main() {
    let f = File::open(&quot;bar.txt&quot;)?;
}
</code></pre>
<p>Since <code>?</code> works by propagating the <code>Result</code> with an early return to the
enclosing function, the snippet above does not work, and results today
in the following error:</p>
<pre><code class="language-rust ignore">error[E0277]: the `?` operator can only be used in a function that returns `Result`
              or `Option` (or another type that implements `std::ops::Try`)
 --&gt; src/main.rs:5:13
  |
5 |     let f = File::open(&quot;bar.txt&quot;)?;
  |             ^^^^^^^^^^^^^^^^^^^^^^ cannot use the `?` operator in a function that returns `()`
  |
  = help: the trait `std::ops::Try` is not implemented for `()`
  = note: required by `std::ops::Try::from_error`
</code></pre>
<p>To solve this problem in Rust 2015, you might have written something like:</p>
<pre><pre class="playpen"><code class="language-rust">// Rust 2015

# use std::process;
# use std::error::Error;

fn run() -&gt; Result&lt;(), Box&lt;Error&gt;&gt; {
    // real logic..
    Ok(())
}

fn main() {
    if let Err(e) = run() {
        println!(&quot;Application error: {}&quot;, e);
        process::exit(1);
    }
}
</code></pre></pre>
<p>However, in this case, the <code>run</code> function has all the interesting logic and
<code>main</code> is just boilerplate. The problem is even worse for <code>#[test]</code>s, since
there tend to be a lot more of them.</p>
<p>In Rust 2018 you can instead let your <code>#[test]</code>s and <code>main</code> functions return
a <code>Result</code>:</p>
<pre><pre class="playpen"><code class="language-rust no_run">// Rust 2018

use std::fs::File;

fn main() -&gt; Result&lt;(), std::io::Error&gt; {
    let f = File::open(&quot;bar.txt&quot;)?;

    Ok(())
}
</code></pre></pre>
<p>In this case, if say the file doesn't exist and there is an <code>Err(err)</code> somewhere,
then <code>main</code> will exit with an error code (not <code>0</code>) and print out a <code>Debug</code>
representation of <code>err</code>.</p>
<a class="header" href="#more-details-1" id="more-details-1"><h2>More details</h2></a>
<p>Getting <code>-&gt; Result&lt;..&gt;</code> to work in the context of <code>main</code> and <code>#[test]</code>s is not
magic. It is all backed up by a <code>Termination</code> trait which all valid return
types of <code>main</code> and testing functions must implement. The trait is defined as:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
pub trait Termination {
    fn report(self) -&gt; i32;
}
#}</code></pre></pre>
<p>When setting up the entry point for your application, the compiler will use this
trait and call <code>.report()</code> on the <code>Result</code> of the <code>main</code> function you have written.</p>
<p>Two simplified example implementations of this trait for <code>Result</code> and <code>()</code> are:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# #![feature(process_exitcode_placeholder, termination_trait_lib)]
# use std::process::ExitCode;
# use std::fmt;
#
# pub trait Termination { fn report(self) -&gt; i32; }

impl Termination for () {
    fn report(self) -&gt; i32 {
        # use std::process::Termination;
        ExitCode::SUCCESS.report()
    }
}

impl&lt;E: fmt::Debug&gt; Termination for Result&lt;(), E&gt; {
    fn report(self) -&gt; i32 {
        match self {
            Ok(()) =&gt; ().report(),
            Err(err) =&gt; {
                eprintln!(&quot;Error: {:?}&quot;, err);
                # use std::process::Termination;
                ExitCode::FAILURE.report()
            }
        }
    }
}
#}</code></pre></pre>
<p>As you can see in the case of <code>()</code>, a success code is simply returned.
In the case of <code>Result</code>, the success case delegates to the implementation for
<code>()</code> but prints out an error message and a failure exit code on <code>Err(..)</code>.</p>
<p>To learn more about the finer details, consult either <a href="https://github.com/rust-lang/rust/issues/43301">the tracking issue</a> or <a href="https://github.com/rust-lang/rfcs/blob/master/text/1937-ques-in-main.md">the RFC</a>.</p>
<a class="header" href="#controlling-panics-with-stdpanic" id="controlling-panics-with-stdpanic"><h1>Controlling panics with <code>std::panic</code></h1></a>
<p><img src="https://img.shields.io/badge/Minimum%20Rust%20Version-1.9-brightgreen.svg" alt="Minimum Rust version: 1.9" /></p>
<p>There is a <code>std::panic</code> module, which includes methods for halting the
unwinding process started by a panic:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use std::panic;

let result = panic::catch_unwind(|| {
    println!(&quot;hello!&quot;);
});
assert!(result.is_ok());

let result = panic::catch_unwind(|| {
    panic!(&quot;oh no!&quot;);
});
assert!(result.is_err());
#}</code></pre></pre>
<p>In general, Rust distinguishes between two ways that an operation can fail:</p>
<ul>
<li>Due to an <em>expected problem</em>, like a file not being found.</li>
<li>Due to an <em>unexpected problem</em>, like an index being out of bounds for an array.</li>
</ul>
<p>Expected problems usually arise from conditions that are outside of your
control; robust code should be prepared for anything its environment might throw
at it. In Rust, expected problems are handled via <a href="http://doc.rust-lang.org/std/result/index.html">the <code>Result</code> type</a>,
which allows a function to return information about the problem to its caller,
which can then handle the error in a fine-grained way.</p>
<p>Unexpected problems are <em>bugs</em>: they arise due to a contract or assertion being
violated. Since they are unexpected, it doesn't make sense to handle them in a
fine-grained way. Instead, Rust employs a &quot;fail fast&quot; approach by <em>panicking</em>,
which by default unwinds the stack (running destructors but no other code) of
the thread which discovered the error. Other threads continue running, but will
discover the panic any time they try to communicate with the panicked thread
(whether through channels or shared memory). Panics thus abort execution up to
some &quot;isolation boundary&quot;, with code on the other side of the boundary still
able to run, and perhaps to &quot;recover&quot; from the panic in some very coarse-grained
way. A server, for example, does not necessarily need to go down just because of
an assertion failure in one of its threads.</p>
<p>It's also worth noting that programs may choose to <em>abort</em> instead of unwind,
and so catching panics may not work. If your code relies on <code>catch_unwind</code>, you
should add this to your Cargo.toml:</p>
<pre><code class="language-toml">[profile.debug]
panic = &quot;unwind&quot;

[profile.release]
panic = &quot;unwind&quot;
</code></pre>
<p>If any of your users choose to abort, they'll get a compile-time failure.</p>
<p>The <code>catch_unwind</code> API offers a way to introduce new isolation boundaries
<em>within a thread</em>. There are a couple of key motivating examples:</p>
<ul>
<li>Embedding Rust in other languages</li>
<li>Abstractions that manage threads</li>
<li>Test frameworks, because tests may panic and you don't want that to kill the test runner</li>
</ul>
<p>For the first case, unwinding across a language boundary is undefined behavior,
and often leads to segfaults in practice. Allowing panics to be caught means
that you can safely expose Rust code via a C API, and translate unwinding into
an error on the C side.</p>
<p>For the second case, consider a threadpool library. If a thread in the pool
panics, you generally don't want to kill the thread itself, but rather catch the
panic and communicate it to the client of the pool. The <code>catch_unwind</code> API is
paired with <code>resume_unwind</code>, which can then be used to restart the panicking
process on the client of the pool, where it belongs.</p>
<p>In both cases, you're introducing a new isolation boundary within a thread, and
then translating the panic into some other form of error elsewhere.</p>
<a class="header" href="#aborting-on-panic" id="aborting-on-panic"><h1>Aborting on panic</h1></a>
<p><img src="https://img.shields.io/badge/Minimum%20Rust%20Version-1.10-brightgreen.svg" alt="Minimum Rust version: 1.10" /></p>
<p>By default, Rust programs will unwind the stack when a <code>panic!</code> happens. If you'd prefer an
immediate abort instead, you can configure this in <code>Cargo.toml</code>:</p>
<pre><code class="language-toml">[profile.debug]
panic = &quot;abort&quot;

[profile.release]
panic = &quot;abort&quot;
</code></pre>
<p>Why might you choose to do this? By removing support for unwinding, you'll
get smaller binaries. You will lose the ability to catch panics. Which choice
is right for you depends on exactly what you're doing.</p>
<a class="header" href="#control-flow" id="control-flow"><h1>Control flow</h1></a>
<p>In this chapter of the guide, we discuss a few improvements to control flow.
The most notable of these <em>will</em> be <a href="async-await-for-easier-concurrency.html"><code>async</code> and <code>await</code></a>.</p>
<a class="header" href="#loops-can-break-with-a-value" id="loops-can-break-with-a-value"><h1><code>loop</code>s can break with a value</h1></a>
<p><img src="https://img.shields.io/badge/Minimum%20Rust%20Version-1.19-brightgreen.svg" alt="Minimum Rust version: 1.19" /></p>
<p><code>loop</code>s can now break with a value:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
// old code
let x;

loop {
    x = 7;
    break;
}

// new code
let x = loop { break 7; };
#}</code></pre></pre>
<p>Rust has traditionally positioned itself as an “expression oriented
language”, that is, most things are expressions that evaluate to a value,
rather than statements. <code>loop</code> stuck out as strange in this way, as it was
previously a statement.</p>
<p>For now, this only applies to <code>loop</code>, and not things like <code>while</code> or <code>for</code>.
It's not clear yet, but we may add this to those in the future.</p>
<a class="header" href="#asyncawait-for-easier-concurrency" id="asyncawait-for-easier-concurrency"><h1>async/await for easier concurrency</h1></a>
<p><img src="https://img.shields.io/badge/Minimum%20Rust%20Version-nightly-red.svg" alt="Minimum Rust version: nightly" /></p>
<p>The initial release of Rust 2018 won't ship with <code>async</code>/<code>await</code> support, but
we have reserved the keywords so that a future release will contain them.
We'll update this page when it's closer to shipping!</p>
<a class="header" href="#trait-system" id="trait-system"><h1>Trait system</h1></a>
<p>In this chapter of the guide, we discuss a few improvements to the trait system.
The most notable of these is <a href="impl-trait-for-returning-complex-types-with-ease.html"><code>impl Trait</code></a>.</p>
<a class="header" href="#impl-trait-for-returning-complex-types-with-ease" id="impl-trait-for-returning-complex-types-with-ease"><h1><code>impl Trait</code> for returning complex types with ease</h1></a>
<p><img src="https://img.shields.io/badge/Minimum%20Rust%20Version-1.26-brightgreen.svg" alt="Minimum Rust version: 1.26" /></p>
<p><code>impl Trait</code> is the new way to specify unnamed but concrete types that
implement a specific trait. There are two places you can put it: argument
position, and return position.</p>
<pre><code class="language-rust ignore">trait Trait {}

// argument position
fn foo(arg: impl Trait) {
}

// return position
fn foo() -&gt; impl Trait {
}
</code></pre>
<a class="header" href="#argument-position" id="argument-position"><h2>Argument Position</h2></a>
<p>In argument position, this feature is quite simple. These two forms are
almost the same:</p>
<pre><code class="language-rust ignore">trait Trait {}

fn foo&lt;T: Trait&gt;(arg: T) {
}

fn foo(arg: impl Trait) {
}
</code></pre>
<p>That is, it's a slightly shorter syntax for a generic type parameter. It
means, &quot;<code>arg</code> is an argument that takes any type that implements the <code>Trait</code>
trait.&quot;</p>
<p>However, there's also an important technical difference between <code>T: Trait</code>
and <code>impl Trait</code> here. When you write the former, you can specify the type of
<code>T</code> at the call site with turbo-fish syntax as with <code>foo::&lt;usize&gt;(1)</code>. In the
case of <code>impl Trait</code>, if it is used anywhere in the function definition, then
you can't use turbo-fish at all. Therefore, you should be mindful that
changing both from and to <code>impl Trait</code> can constitute a breaking change for
the users of your code.</p>
<a class="header" href="#return-position" id="return-position"><h2>Return Position</h2></a>
<p>In return position, this feature is more interesting. It means &quot;I am
returning some type that implements the <code>Trait</code> trait, but I'm not going to
tell you exactly what the type is.&quot; Before <code>impl Trait</code>, you could do this
with trait objects:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
trait Trait {}

impl Trait for i32 {}

fn returns_a_trait_object() -&gt; Box&lt;dyn Trait&gt; {
    Box::new(5)
}
#}</code></pre></pre>
<p>However, this has some overhead: the <code>Box&lt;T&gt;</code> means that there's a heap
allocation here, and this will use dynamic dispatch. See the <code>dyn Trait</code>
section for an explanation of this syntax. But we only ever return one
possible thing here, the <code>Box&lt;i32&gt;</code>. This means that we're paying for dynamic
dispatch, even though we don't use it!</p>
<p>With <code>impl Trait</code>, the code above could be written like this:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
trait Trait {}

impl Trait for i32 {}

fn returns_a_trait_object() -&gt; impl Trait {
    5
}
#}</code></pre></pre>
<p>Here, we have no <code>Box&lt;T&gt;</code>, no trait object, and no dynamic dispatch. But we
still can obscure the <code>i32</code> return type.</p>
<p>With <code>i32</code>, this isn't super useful. But there's one major place in Rust
where this is much more useful: closures.</p>
<a class="header" href="#impl-trait-and-closures" id="impl-trait-and-closures"><h3><code>impl Trait</code> and closures</h3></a>
<blockquote>
<p>If you need to catch up on closures, check out <a href="https://doc.rust-lang.org/book/second-edition/ch13-01-closures.html">their chapter in the
book</a>.</p>
</blockquote>
<p>In Rust, closures have a unique, un-writable type. They do implement the <code>Fn</code>
family of traits, however. This means that previously, the only way to return
a closure from a function was to use a trait object:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
fn returns_closure() -&gt; Box&lt;dyn Fn(i32) -&gt; i32&gt; {
    Box::new(|x| x + 1)
}
#}</code></pre></pre>
<p>You couldn't write the type of the closure, only use the <code>Fn</code> trait. That means
that the trait object is necessary. However, with <code>impl Trait</code>:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
fn returns_closure() -&gt; impl Fn(i32) -&gt; i32 {
    |x| x + 1
}
#}</code></pre></pre>
<p>We can now return closures by value, just like any other type!</p>
<a class="header" href="#more-details-2" id="more-details-2"><h2>More details</h2></a>
<p>The above is all you need to know to get going with <code>impl Trait</code>, but for
some more nitty-gritty details: type parameters and <code>impl Trait</code> in argument
position are universals (universally quantified types). Meanwhile, <code>impl Trait</code> in return position are existentials (existentially quantified types).
Okay, maybe that's a bit too jargon-heavy. Let's step back.</p>
<p>Consider this function:</p>
<pre><code class="language-rust ignore">fn foo&lt;T: Trait&gt;(x: T) {
</code></pre>
<p>When you call it, you set the type, <code>T</code>. &quot;you&quot; being the caller here. This
signature says &quot;I accept any type that implements Trait.&quot; (&quot;any type&quot; ==
universal in the jargon)</p>
<p>This version:</p>
<pre><code class="language-rust ignore">fn foo&lt;T: Trait&gt;() -&gt; T {
</code></pre>
<p>is similar, but also different. You, the caller, provide the type you want,
<code>T</code>, and then the function returns it. You can see this in Rust today with
things like parse or collect:</p>
<pre><code class="language-rust ignore">let x: i32 = &quot;5&quot;.parse()?;
let x: u64 = &quot;5&quot;.parse()?;
</code></pre>
<p>Here, <code>.parse</code> has this signature:</p>
<pre><code class="language-rust ignore">pub fn parse&lt;F&gt;(&amp;self) -&gt; Result&lt;F, &lt;F as FromStr&gt;::Err&gt; where
    F: FromStr,
</code></pre>
<p>Same general idea, though with a result type and <code>FromStr</code> has an associated
type... anyway, you can see how <code>F</code> is in the return position here. So you
have the ability to choose.</p>
<p>With <code>impl Trait</code>, you're saying &quot;hey, some type exists that implements this
trait, but I'm not gonna tell you what it is.&quot; (&quot;existential&quot; in the jargon,
&quot;some type exists&quot;). So now, the caller can't choose, and the function itself
gets to choose. If we tried to define parse with <code>Result&lt;impl F,...</code> as the
return type, it wouldn't work.</p>
<a class="header" href="#using-impl-trait-in-more-places" id="using-impl-trait-in-more-places"><h3>Using <code>impl Trait</code> in more places</h3></a>
<p>As previously mentioned, as a start, you will only be able to use <code>impl Trait</code>
as the argument or return type of a free or inherent function. However,
<code>impl Trait</code> can't be used inside implementations of traits, nor can it be
used as the type of a let binding or inside a type alias. Some of these
restrictions will eventually be lifted. For more information, see the
<a href="https://github.com/rust-lang/rust/issues/34511">tracking issue on <code>impl Trait</code></a>.</p>
<a class="header" href="#dyn-trait-for-trait-objects" id="dyn-trait-for-trait-objects"><h1><code>dyn Trait</code> for trait objects</h1></a>
<p><img src="https://img.shields.io/badge/Minimum%20Rust%20Version-1.27-brightgreen.svg" alt="Minimum Rust version: 1.27" /></p>
<p>The <code>dyn Trait</code> feature is the new syntax for using trait objects. In short:</p>
<ul>
<li><code>Box&lt;Trait&gt;</code> becomes <code>Box&lt;dyn Trait&gt;</code></li>
<li><code>&amp;Trait</code> and <code>&amp;mut Trait</code> become <code>&amp;dyn Trait</code> and <code>&amp;mut dyn Trait</code></li>
</ul>
<p>And so on. In code:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
trait Trait {}

impl Trait for i32 {}

// old
fn function1() -&gt; Box&lt;Trait&gt; {
# unimplemented!()
}

// new
fn function2() -&gt; Box&lt;dyn Trait&gt; {
# unimplemented!()
}
#}</code></pre></pre>
<p>That's it!</p>
<a class="header" href="#more-details-3" id="more-details-3"><h2>More details</h2></a>
<p>Using just the trait name for trait objects turned out to be a bad decision.
The current syntax is often ambiguous and confusing, even to veterans,
and favors a feature that is not more frequently used than its alternatives,
is sometimes slower, and often cannot be used at all when its alternatives can.</p>
<p>Furthermore, with <code>impl Trait</code> arriving, &quot;<code>impl Trait</code> vs <code>dyn Trait</code>&quot; is much
more symmetric, and therefore a bit nicer, than &quot;<code>impl Trait</code> vs <code>Trait</code>&quot;.
<code>impl Trait</code> is explained further in the next section.</p>
<p>In the new edition, you should therefore prefer <code>dyn Trait</code> to just <code>Trait</code>
where you need a trait object.</p>
<a class="header" href="#more-container-types-support-trait-objects" id="more-container-types-support-trait-objects"><h1>More container types support trait objects</h1></a>
<p><img src="https://img.shields.io/badge/Minimum%20Rust%20Version-1.2-brightgreen.svg" alt="Minimum Rust version: 1.2" /></p>
<p>In Rust 1.0, only certain, special types could be used to create <a href="https://doc.rust-lang.org/book/second-edition/ch17-02-trait-objects.html">trait
objects</a>.</p>
<p>With Rust 1.2, that restriction was lifted, and more types became able to do this. For example,
<code>Rc&lt;T&gt;</code>, one of Rust's reference-counted types:</p>
<pre><pre class="playpen"><code class="language-rust">use std::rc::Rc;

trait Foo {}

impl Foo for i32 {
    
}

fn main() {
    let obj: Rc&lt;dyn Foo&gt; = Rc::new(5);
}
</code></pre></pre>
<p>This code would not work with Rust 1.0, but now works.</p>
<blockquote>
<p>If you haven't seen the <code>dyn</code> syntax before, see the section on it. For
versions that do not support it, replace <code>Rc&lt;dyn Foo&gt;</code> with <code>Rc&lt;Foo&gt;</code>.</p>
</blockquote>
<a class="header" href="#associated-constants" id="associated-constants"><h1>Associated constants</h1></a>
<p><img src="https://img.shields.io/badge/Minimum%20Rust%20Version-1.20-brightgreen.svg" alt="Minimum Rust version: 1.20" /></p>
<p>You can define traits, structs, and enums that have “associated functions”:</p>
<pre><pre class="playpen"><code class="language-rust">struct Struct;

impl Struct {
    fn foo() {
        println!(&quot;foo is an associated function of Struct&quot;);
    }
}

fn main() {
    Struct::foo();
}
</code></pre></pre>
<p>These are called “associated functions” because they are functions that are
associated with the type, that is, they’re attached to the type itself, and
not any particular instance.</p>
<p>Rust 1.20 adds the ability to define “associated constants” as well:</p>
<pre><pre class="playpen"><code class="language-rust">struct Struct;

impl Struct {
    const ID: u32 = 0;
}

fn main() {
    println!(&quot;the ID of Struct is: {}&quot;, Struct::ID);
}
</code></pre></pre>
<p>That is, the constant <code>ID</code> is associated with <code>Struct</code>. Like functions,
associated constants work with traits and enums as well.</p>
<p>Traits have an extra ability with associated constants that gives them some
extra power. With a trait, you can use an associated constant in the same way
you’d use an associated type: by declaring it, but not giving it a value. The
implementor of the trait then declares its value upon implementation:</p>
<pre><pre class="playpen"><code class="language-rust">trait Trait {
    const ID: u32;
}

struct Struct;

impl Trait for Struct {
    const ID: u32 = 5;
}

fn main() {
    println!(&quot;{}&quot;, Struct::ID);
}
</code></pre></pre>
<p>Before this feature, if you wanted to make a trait that represented floating
point numbers, you’d have to write this:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
trait Float {
    fn nan() -&gt; Self;
    fn infinity() -&gt; Self;
    // ...
}
#}</code></pre></pre>
<p>This is slightly unwieldy, but more importantly, because they’re functions,
they cannot be used in constant expressions, even though they only return a
constant. Because of this, a design for <code>Float</code> would also have to include
constants as well:</p>
<pre><code class="language-rust ignore">mod f32 {
    const NAN: f32 = 0.0f32 / 0.0f32;
    const INFINITY: f32 = 1.0f32 / 0.0f32;

    impl Float for f32 {
        fn nan() -&gt; Self {
            f32::NAN
        }
        fn infinity() -&gt; Self {
            f32::INFINITY
        }
    }
}
</code></pre>
<p>Associated constants let you do this in a much cleaner way. This trait
definition:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
trait Float {
    const NAN: Self;
    const INFINITY: Self;
    // ...
}
#}</code></pre></pre>
<p>Leads to this implementation:</p>
<pre><code class="language-rust ignore">mod f32 {
    impl Float for f32 {
        const NAN: f32 = 0.0f32 / 0.0f32;
        const INFINITY: f32 = 1.0f32 / 0.0f32;
    }
}
</code></pre>
<p>much cleaner, and more versatile.</p>
<a class="header" href="#slice-patterns" id="slice-patterns"><h1>Slice patterns</h1></a>
<p><img src="https://img.shields.io/badge/Minimum%20Rust%20Version-1.26-brightgreen.svg" alt="Minimum Rust version: 1.26" /></p>
<p>Have you ever tried to pattern match on the contents and structure of a slice?
Rust 2018 will let you do just that.</p>
<p>For example, say we want to accept a list of names and respond to that with a
greeting. With slice patterns, we can do that easy as pie with:</p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    greet(&amp;[]);
    // output: Bummer, there's no one here :(
    greet(&amp;[&quot;Alan&quot;]);
    // output: Hey, there Alan! You seem to be alone.
    greet(&amp;[&quot;Joan&quot;, &quot;Hugh&quot;]);
    // output: Hello, Joan and Hugh. Nice to see you are at least 2!
    greet(&amp;[&quot;John&quot;, &quot;Peter&quot;, &quot;Stewart&quot;]);
    // output: Hey everyone, we seem to be 3 here today.
}

fn greet(people: &amp;[&amp;str]) {
    match people {
        [] =&gt; println!(&quot;Bummer, there's no one here :(&quot;),
        [only_one] =&gt; println!(&quot;Hey, there {}! You seem to be alone.&quot;, only_one),
        [first, second] =&gt; println!(
            &quot;Hello, {} and {}. Nice to see you are at least 2!&quot;,
            first, second
        ),
        _ =&gt; println!(&quot;Hey everyone, we seem to be {} here today.&quot;, people.len()),
    }
}
</code></pre></pre>
<p>Now, you don't have to check the length first.</p>
<p>We can also match on arrays like so:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let arr = [1, 2, 3];

assert_eq!(&quot;ends with 3&quot;, match arr {
    [_, _, 3] =&gt; &quot;ends with 3&quot;,
    [a, b, c] =&gt; &quot;ends with something else&quot;,
});
#}</code></pre></pre>
<a class="header" href="#more-details-4" id="more-details-4"><h2>More details</h2></a>
<a class="header" href="#exhaustive-patterns" id="exhaustive-patterns"><h3>Exhaustive patterns</h3></a>
<p>In the first example, note in particular the <code>_ =&gt; ...</code> pattern.
Since we are matching on a slice, it could be of any length, so we need a
<em>&quot;catch all pattern&quot;</em> to handle it. If we forgot the <code>_ =&gt; ...</code> or
<code>identifier =&gt; ...</code> pattern, we would instead get an error saying:</p>
<pre><code class="language-ignore">error[E0004]: non-exhaustive patterns: `&amp;[_, _, _]` not covered
</code></pre>
<p>If we added a case for a slice of size <code>3</code> we would instead get:</p>
<pre><code class="language-ignore">error[E0004]: non-exhaustive patterns: `&amp;[_, _, _, _]` not covered
</code></pre>
<p>and so on...</p>
<a class="header" href="#arrays-and-exact-lengths" id="arrays-and-exact-lengths"><h3>Arrays and exact lengths</h3></a>
<p>In the second example above, since arrays in Rust are of known lengths,
we have to match on exactly three elements.
If we try to match on 2 or 4 elements,we get the errors:</p>
<pre><code class="language-ignore">error[E0527]: pattern requires 2 elements but array has 3
</code></pre>
<p>and</p>
<pre><code class="language-ignore">error[E0527]: pattern requires 4 elements but array has 3
</code></pre>
<a class="header" href="#in-the-pipeline" id="in-the-pipeline"><h3>In the pipeline</h3></a>
<p>When it comes to slice patterns, more advanced forms are planned but
have not been stabilized yet. To learn more, follow <a href="https://github.com/rust-lang/rust/issues/23121">the tracking issue</a>.</p>
<a class="header" href="#ownership-and-lifetimes" id="ownership-and-lifetimes"><h1>Ownership and lifetimes</h1></a>
<p>In this chapter of the guide, we discuss a few improvements to ownership and lifetimes.
One of the most notable of these is <a href="default-match-binding.html">default match binding modes</a>.</p>
<a class="header" href="#default-match-bindings" id="default-match-bindings"><h1>Default match bindings</h1></a>
<p><img src="https://img.shields.io/badge/Minimum%20Rust%20Version-1.26-brightgreen.svg" alt="Minimum Rust version: 1.26" /></p>
<p>Have you ever had a borrowed <code>Option&lt;T&gt;</code> and tried to match on it? You
probably wrote this:</p>
<pre><code class="language-rust ignore">let s: &amp;Option&lt;String&gt; = &amp;Some(&quot;hello&quot;.to_string());

match s {
    Some(s) =&gt; println!(&quot;s is: {}&quot;, s),
    _ =&gt; (),
};
</code></pre>
<p>In Rust 2015, this would fail to compile, and you would have to write the
following instead:</p>
<pre><code class="language-rust ignore">// Rust 2015

let s: &amp;Option&lt;String&gt; = &amp;Some(&quot;hello&quot;.to_string());

match s {
    &amp;Some(ref s) =&gt; println!(&quot;s is: {}&quot;, s),
    _ =&gt; (),
};
</code></pre>
<p>Rust 2018, by contrast, will infer the <code>&amp;</code>s and <code>ref</code>s, and your original
code will Just Work.</p>
<p>This affects not just <code>match</code>, but patterns everywhere, such as in <code>let</code>
statements, closure arguments, and <code>for</code> loops.</p>
<a class="header" href="#more-details-5" id="more-details-5"><h2>More details</h2></a>
<p>The mental model of patterns has shifted a bit with this change, to bring it
into line with other aspects of the language. For example, when writing a
<code>for</code> loop, you can iterate over borrowed contents of a collection by
borrowing the collection itself:</p>
<pre><code class="language-rust ignore">let my_vec: Vec&lt;i32&gt; = vec![0, 1, 2];

for x in &amp;my_vec { ... }
</code></pre>
<p>The idea is that an <code>&amp;T</code> can be understood as a <em>borrowed view of <code>T</code></em>, and
so when you iterate, match, or otherwise destructure a <code>&amp;T</code> you get a
borrowed view of its internals as well.</p>
<p>More formally, patterns have a &quot;binding mode,&quot; which is either by value
(<code>x</code>), by reference (<code>ref x</code>), or by mutable reference (<code>ref mut x</code>). In Rust
2015, <code>match</code> always started in by-value mode, and required you to explicitly
write <code>ref</code> or <code>ref mut</code> in patterns to switch to a borrowing mode. In Rust
2018, the type of the value being matched informs the binding mode, so that
if you match against an <code>&amp;Option&lt;String&gt;</code> with a <code>Some</code> variant, you are put
into <code>ref</code> mode automatically, giving you a borrowed view of the internal
data. Similarly, <code>&amp;mut Option&lt;String&gt;</code> would give you a <code>ref mut</code> view.</p>
<a class="header" href="#a_-the-anonymous-lifetime" id="a_-the-anonymous-lifetime"><h1><code>'_</code>, the anonymous lifetime</h1></a>
<p><img src="https://img.shields.io/badge/Minimum%20Rust%20Version-nightly-red.svg" alt="Minimum Rust version: nightly" /></p>
<p>Rust 2018 allows you to explicitly mark where a lifetime is elided, for types
where this elision might otherwise be unclear. To do this, you can use the
special lifetime <code>'_</code> much like you can explicitly mark that a type is inferred
with the syntax <code>let x: _ = ..;</code>.</p>
<p>Let's say, for whatever reason, that we have a simple wrapper around <code>&amp;'a str</code>:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
struct StrWrap&lt;'a&gt;(&amp;'a str);
#}</code></pre></pre>
<p>In Rust 2015, you might have written:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
// Rust 2015

use std::fmt;

# struct StrWrap&lt;'a&gt;(&amp;'a str);

fn make_wrapper(string: &amp;str) -&gt; StrWrap {
    StrWrap(string)
}

impl&lt;'a&gt; fmt::Debug for StrWrap&lt;'a&gt; {
    fn fmt(&amp;self, fmt: &amp;mut fmt::Formatter) -&gt; fmt::Result {
        fmt.write_str(self.0)
    }
}
#}</code></pre></pre>
<p>In Rust 2018, you can instead write:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#![feature(rust_2018_preview)]

#fn main() {
# use std::fmt;
# struct StrWrap&lt;'a&gt;(&amp;'a str);

// Rust 2018

fn make_wrapper(string: &amp;str) -&gt; StrWrap&lt;'_&gt; {
    StrWrap(string)
}

impl fmt::Debug for StrWrap&lt;'_&gt; {
    fn fmt(&amp;self, fmt: &amp;mut fmt::Formatter&lt;'_&gt;) -&gt; fmt::Result {
        fmt.write_str(self.0)
    }
}
#}</code></pre></pre>
<a class="header" href="#more-details-6" id="more-details-6"><h2>More details</h2></a>
<p>In the Rust 2015 snippet above, we've used <code>-&gt; StrWrap</code>. However, unless you take
a look at the definition of <code>StrWrap</code>, it is not clear that the returned value
is actually borrowing something. Therefore, starting with Rust 2018, it is
deprecated to leave off the lifetime parameters for non-reference-types (types
other than <code>&amp;</code> and <code>&amp;mut</code>). Instead, where you previously wrote <code>-&gt; StrWrap</code>,
you should now write <code>-&gt; StrWrap&lt;'_&gt;</code>, making clear that borrowing is occurring.</p>
<p>What exactly does <code>'_</code> mean? It depends on the context!
In output contexts, as in the return type of <code>make_wrapper</code>,
it refers to a single lifetime for  all &quot;output&quot; locations.
In input contexts, a fresh lifetime is generated for each &quot;input location&quot;.
More concretely, to understand input contexts, consider the following example:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
// Rust 2015

struct Foo&lt;'a, 'b: 'a&gt; {
    field: &amp;'a &amp;'b str,
}

impl&lt;'a, 'b: 'a&gt; Foo&lt;'a, 'b&gt; {
    // some methods...
}
#}</code></pre></pre>
<p>We can rewrite this as:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#![feature(rust_2018_preview)]

#fn main() {
# struct Foo&lt;'a, 'b: 'a&gt; {
#     field: &amp;'a &amp;'b str,
# }

// Rust 2018

impl Foo&lt;'_, '_&gt; {
    // some methods...
}
#}</code></pre></pre>
<p>This is the same, because for each <code>'_</code>, a fresh lifetime is generated.
Finally, the relationship <code>'a: 'b</code> which the struct requires must be upheld.</p>
<p>For more details, see the <a href="https://github.com/rust-lang/rust/issues/44524">tracking issue on In-band lifetime bindings</a>.</p>
<a class="header" href="#lifetime-elision-in-impl" id="lifetime-elision-in-impl"><h1>Lifetime elision in impl</h1></a>
<p><img src="https://img.shields.io/badge/Minimum%20Rust%20Version-nightly-red.svg" alt="Minimum Rust version: nightly" /></p>
<p>When writing an <code>impl</code>, you can mention lifetimes without them being bound in
the argument list.</p>
<p>In Rust 2015:</p>
<pre><code class="language-rust ignore">impl&lt;'a&gt; Iterator for MyIter&lt;'a&gt; { ... }
impl&lt;'a, 'b&gt; SomeTrait&lt;'a&gt; for SomeType&lt;'a, 'b&gt; { ... }
</code></pre>
<p>In Rust 2018:</p>
<pre><code class="language-rust ignore">impl Iterator for MyIter&lt;'iter&gt; { ... }
impl SomeTrait&lt;'tcx&gt; for SomeType&lt;'tcx, 'gcx&gt; { ... }
</code></pre>
<a class="header" href="#t-a-inference-in-structs" id="t-a-inference-in-structs"><h1><code>T: 'a</code> inference in structs</h1></a>
<p><img src="https://img.shields.io/badge/Minimum%20Rust%20Version-nightly-red.svg" alt="Minimum Rust version: nightly" /></p>
<p>An annotation in the form of <code>T: 'a</code>, where <code>T</code> is either a type or another
lifetime, is called an <em>&quot;outlives&quot;</em> requirement. Note that <em>&quot;outlives&quot;</em> also
implies <code>'a: 'a</code>.</p>
<p>One way in which edition 2018 helps you out in maintaining flow when writing
programs is by removing the need to explicitly annotate these <code>T: 'a</code> outlives
requirements in <code>struct</code> definitions. Instead, the requirements will be
inferred from the fields present in the definitions.</p>
<p>Consider the following <code>struct</code> definitions in Rust 2015:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
// Rust 2015

struct Ref&lt;'a, T: 'a&gt; {
    field: &amp;'a T
}

// or written with a `where` clause:

struct WhereRef&lt;'a, T&gt; where T: 'a {
    data: &amp;'a T
}

// with nested references:

struct RefRef&lt;'a, 'b: 'a, T: 'b&gt; {
    field: &amp;'a &amp;'b T,
}

// using an associated type:

struct ItemRef&lt;'a, T: Iterator&gt;
where
    T::Item: 'a
{
    field: &amp;'a T::Item
}
#}</code></pre></pre>
<p>In Rust 2018, since the requirements are inferred, you can instead write:</p>
<pre><code class="language-rust ignore">// Rust 2018

struct Ref&lt;'a, T&gt; {
    field: &amp;'a T
}

struct WhereRef&lt;'a, T&gt; {
    data: &amp;'a T
}

struct RefRef&lt;'a, 'b, T&gt; {
    field: &amp;'a &amp;'b T,
}

struct ItemRef&lt;'a, T: Iterator&gt; {
    field: &amp;'a T::Item
}
</code></pre>
<p>If you prefer to be more explicit in some cases, that is still possible.</p>
<a class="header" href="#more-details-7" id="more-details-7"><h2>More details</h2></a>
<p>For more details, see <a href="https://github.com/rust-lang/rust/issues/44493">the tracking issue</a>
and <a href="https://github.com/rust-lang/rfcs/pull/2093">the RFC</a>.</p>
<a class="header" href="#simpler-lifetimes-in-static-and-const" id="simpler-lifetimes-in-static-and-const"><h1>Simpler lifetimes in <code>static</code> and <code>const</code></h1></a>
<p><img src="https://img.shields.io/badge/Minimum%20Rust%20Version-1.17-brightgreen.svg" alt="Minimum Rust version: 1.17" /></p>
<p>In older Rust, you had to explicitly write the <code>'static</code> lifetime in any
<code>static</code> or <code>const</code> that needed a lifetime:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# mod foo {
const NAME: &amp;'static str = &quot;Ferris&quot;;
# }
# mod bar {
static NAME: &amp;'static str = &quot;Ferris&quot;;
# }
#}</code></pre></pre>
<p>But <code>'static</code> is the only possible lifetime there. So Rust now assumes the <code>'static</code> lifetime,
and you don't have to write it out:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# mod foo {
const NAME: &amp;str = &quot;Ferris&quot;;
# }
# mod bar {
static NAME: &amp;str = &quot;Ferris&quot;;
# }
#}</code></pre></pre>
<p>In some situations, this can remove a <em>lot</em> of boilerplate:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# mod foo {
// old
const NAMES: &amp;'static [&amp;'static str; 2] = &amp;[&quot;Ferris&quot;, &quot;Bors&quot;];
# }
# mod bar {

// new
const NAMES: &amp;[&amp;str; 2] = &amp;[&quot;Ferris&quot;, &quot;Bors&quot;];
# }
#}</code></pre></pre>
<a class="header" href="#data-types" id="data-types"><h1>Data types</h1></a>
<p>In this chapter of the guide, we discuss a few improvements to data types.
One of these are <a href="field-init-shorthand.html">field-init-shorthand</a>.</p>
<a class="header" href="#field-init-shorthand" id="field-init-shorthand"><h1>Field init shorthand</h1></a>
<p><img src="https://img.shields.io/badge/Minimum%20Rust%20Version-1.17-brightgreen.svg" alt="Minimum Rust version: 1.17" /></p>
<p>In older Rust, when initializing a struct, you must always give the full set of <code>key: value</code> pairs
for its fields:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
struct Point {
    x: i32,
    y: i32,
}

let a = 5;
let b = 6;

let p = Point {
    x: a,
    y: b,
};
#}</code></pre></pre>
<p>However, often these variables would have the same names as the fields. So you'd end up
with code that looks like this:</p>
<pre><code class="language-rust ignore">let p = Point {
    x: x,
    y: y,
};
</code></pre>
<p>Now, if the variable is of the same name, you don't have to write out both, just write out the key:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
struct Point {
    x: i32,
    y: i32,
}

let x = 5;
let y = 6;

// new
let p = Point {
    x,
    y,
};
#}</code></pre></pre>
<a class="header" href="#a-for-inclusive-ranges" id="a-for-inclusive-ranges"><h1><code>..=</code> for inclusive ranges</h1></a>
<p><img src="https://img.shields.io/badge/Minimum%20Rust%20Version-1.26-brightgreen.svg" alt="Minimum Rust version: 1.26" /></p>
<p>Since well before Rust 1.0, you’ve been able to create exclusive ranges with
.. like this:</p>
<pre><code>for i in 1..3 {
    println!(&quot;i: {}&quot;, i);
}
</code></pre>
<p>This will print <code>i: 1</code> and then <code>i: 2</code>. Today, you can now create an
inclusive range, like this:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
for i in 1..=3 {
    println!(&quot;i: {}&quot;, i);
}
#}</code></pre></pre>
<p>This will print <code>i: 1</code> and then <code>i: 2</code> like before, but also <code>i: 3</code>; the
three is included in the range. Inclusive ranges are especially useful if you
want to iterate over every possible value in a range. For example, this is a
surprising Rust program:</p>
<pre><pre class="playpen"><code class="language-rust">fn takes_u8(x: u8) {
    // ...
}

fn main() {
    for i in 0..256 {
        println!(&quot;i: {}&quot;, i);
        takes_u8(i);
    }
}
</code></pre></pre>
<p>What does this program do? The answer: nothing. The warning we get when
compiling has a hint:</p>
<pre><code class="language-text">warning: literal out of range for u8
 --&gt; src/main.rs:6:17
  |
6 |     for i in 0..256 {
  |                 ^^^
  |
  = note: #[warn(overflowing_literals)] on by default
</code></pre>
<p>That’s right, since <code>i</code> is a <code>u8</code>, this overflows, and is the same as writing
<code>for i in 0..0</code>, so the loop executes zero times.</p>
<p>We can do this with inclusive ranges, however:</p>
<pre><pre class="playpen"><code class="language-rust">fn takes_u8(x: u8) {
    // ...
}

fn main() {
    for i in 0..=255 {
        println!(&quot;i: {}&quot;, i);
        takes_u8(i);
    }
}
</code></pre></pre>
<p>This will produce those 256 lines of output you might have been expecting.</p>
<a class="header" href="#a128-bit-integers" id="a128-bit-integers"><h1>128 bit integers</h1></a>
<p><img src="https://img.shields.io/badge/Minimum%20Rust%20Version-1.26-brightgreen.svg" alt="Minimum Rust version: 1.26" /></p>
<p>A very simple feature: Rust now has 128 bit integers!</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let x: i128 = 0;
let y: u128 = 0;
#}</code></pre></pre>
<p>These are twice the size of <code>u64</code>, and so can hold more values. More specifically,</p>
<ul>
<li><code>u128</code>: <code>0</code> - <code>340,282,366,920,938,463,463,374,607,431,768,211,455</code></li>
<li><code>i128</code>: <code>−170,141,183,460,469,231,731,687,303,715,884,105,728</code> - <code>170,141,183,460,469,231,731,687,303,715,884,105,727</code></li>
</ul>
<p>Whew!</p>
<a class="header" href="#operator-equals-are-now-implementable" id="operator-equals-are-now-implementable"><h1>&quot;Operator-equals&quot; are now implementable</h1></a>
<p><img src="https://img.shields.io/badge/Minimum%20Rust%20Version-1.8-brightgreen.svg" alt="Minimum Rust version: 1.8" /></p>
<p>The various “operator equals” operators, such as <code>+=</code> and <code>-=</code>, are
implementable via various traits. For example, to implement <code>+=</code> on
a type of your own:</p>
<pre><pre class="playpen"><code class="language-rust">use std::ops::AddAssign;

#[derive(Debug)]
struct Count { 
    value: i32,
}

impl AddAssign for Count {
    fn add_assign(&amp;mut self, other: Count) {
        self.value += other.value;
    }
}

fn main() {
    let mut c1 = Count { value: 1 };
    let c2 = Count { value: 5 };

    c1 += c2;

    println!(&quot;{:?}&quot;, c1);
}
</code></pre></pre>
<p>This will print <code>Count { value: 6 }</code>.</p>
<a class="header" href="#union-for-an-unsafe-form-of-enum" id="union-for-an-unsafe-form-of-enum"><h1><code>union</code> for an unsafe form of <code>enum</code></h1></a>
<p><img src="https://img.shields.io/badge/Minimum%20Rust%20Version-1.19-brightgreen.svg" alt="Minimum Rust version: 1.19" /></p>
<p>Rust now supports <code>unions</code>:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
union MyUnion {
    f1: u32,
    f2: f32,
}
#}</code></pre></pre>
<p>Unions are kind of like enums, but they are “untagged”. Enums have a “tag”
that stores which variant is the correct one at runtime; unions don't have
this tag.</p>
<p>Since we can interpret the data held in the union using the wrong variant and
Rust can’t check this for us, that means reading or writing a union’s field
is unsafe:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# union MyUnion {
#     f1: u32,
#     f2: f32,
# }
let mut u = MyUnion { f1: 1 };

unsafe { u.f1 = 5 };

let value = unsafe { u.f1 };
#}</code></pre></pre>
<p>Pattern matching works too:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# union MyUnion {
#     f1: u32,
#     f2: f32,
# }
fn f(u: MyUnion) {
    unsafe {
        match u {
            MyUnion { f1: 10 } =&gt; { println!(&quot;ten&quot;); }
            MyUnion { f2 } =&gt; { println!(&quot;{}&quot;, f2); }
        }
    }
}
#}</code></pre></pre>
<p>When are unions useful? One major use-case is interoperability with C. C APIs
can (and depending on the area, often do) expose unions, and so this makes
writing API wrappers for those libraries significantly easier. Additionally,
unions also simplify Rust implementations of space-efficient or
cache-efficient structures relying on value representation, such as
machine-word-sized unions using the least-significant bits of aligned
pointers to distinguish cases.</p>
<p>There’s still more improvements to come. For now, unions can only include
<code>Copy</code> types and may not implement <code>Drop</code>. We expect to lift these
restrictions in the future.</p>
<a class="header" href="#choosing-alignment-with-the-repr-attribute" id="choosing-alignment-with-the-repr-attribute"><h1>Choosing alignment with the repr attribute</h1></a>
<p><img src="https://img.shields.io/badge/Minimum%20Rust%20Version-1.25-brightgreen.svg" alt="Minimum Rust version: 1.25" /></p>
<p>From <a href="https://en.wikipedia.org/wiki/Data_structure_alignment">Wikipedia</a>:</p>
<blockquote>
<p>The CPU in modern computer hardware performs reads and writes to memory
most efficiently when the data is naturally aligned, which generally means
that the data address is a multiple of the data size. Data alignment refers
to aligning elements according to their natural alignment. To ensure natural
alignment, it may be necessary to insert some padding between structure
elements or after the last element of a structure.</p>
</blockquote>
<p>The <code>#[repr]</code> attribute has a new parameter, <code>align</code>, that sets the alignment of your struct:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
struct Number(i32);

assert_eq!(std::mem::align_of::&lt;Number&gt;(), 4);
assert_eq!(std::mem::size_of::&lt;Number&gt;(), 4);

#[repr(align(16))]
struct Align16(i32);

assert_eq!(std::mem::align_of::&lt;Align16&gt;(), 16);
assert_eq!(std::mem::size_of::&lt;Align16&gt;(), 16);
#}</code></pre></pre>
<p>If you’re working with low-level stuff, control of these kinds of things can
be very important!</p>
<p>The alignment of a type is normally not worried about as the compiler will
&quot;do the right thing&quot; of picking an appropriate alignment for general use
cases. There are situations, however, where a nonstandard alignment may be
desired when operating with foreign systems. For example these sorts of
situations tend to necessitate or be much easier with a custom alignment:</p>
<ul>
<li>Hardware can often have obscure requirements such as &quot;this structure is
aligned to 32 bytes&quot; when it in fact is only composed of 4-byte values. While
this can typically be manually calculated and managed, it's often also useful
to express this as a property of a type to get the compiler to do a little
extra work instead.</li>
<li>C compilers like <code>gcc</code> and <code>clang</code> offer the ability to specify a custom
alignment for structures, and Rust can much more easily interoperate with
these types if Rust can also mirror the request for a custom alignment (e.g.
passing a structure to C correctly is much easier).</li>
<li>Custom alignment can often be used for various tricks here and there and is
often convenient as &quot;let's play around with an implementation&quot; tool. For
example this can be used to statically allocate page tables in a kernel or
create an at-least cache-line-sized structure easily for concurrent
programming.</li>
</ul>
<p>The purpose of this feature is to provide a lightweight annotation to alter
the compiler-inferred alignment of a structure to enable these situations
much more easily.</p>
<a class="header" href="#simd-for-faster-computing" id="simd-for-faster-computing"><h1>SIMD for faster computing</h1></a>
<p><img src="https://img.shields.io/badge/Minimum%20Rust%20Version-1.27-brightgreen.svg" alt="Minimum Rust version: 1.27" /></p>
<p>The basics of <a href="https://en.wikipedia.org/wiki/SIMD">SIMD</a> are now available!
SIMD stands for “single instruction, multiple data.” Consider a function like
this:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
pub fn foo(a: &amp;[u8], b: &amp;[u8], c: &amp;mut [u8]) {
    for ((a, b), c) in a.iter().zip(b).zip(c) {
        *c = *a + *b;
    }
}
#}</code></pre></pre>
<p>Here, we’re taking two slices, and adding the numbers together, placing the
result in a third slice. The simplest possible way to do this would be to do
exactly what the code does, and loop through each set of elements, add them
together, and store it in the result. However, compilers can often do better.
LLVM will usually “autovectorize” code like this, which is a fancy term for
“use SIMD.” Imagine that <code>a</code> and <code>b</code> were both 16 elements long. Each element
is a <code>u8</code>, and so that means that each slice would be 128 bits of data. Using
SIMD, we could put both <code>a</code> and <code>b</code> into 128 bit registers, add them together
in a <em>single</em> instruction, and then copy the resulting 128 bits into <code>c</code>.
That’d be much faster!</p>
<p>While stable Rust has always been able to take advantage of
autovectorization, sometimes, the compiler just isn’t smart enough to realize
that we can do something like this. Additionally, not every CPU has these
features, and so LLVM may not use them so your program can be used on a wide
variety of hardware. The <code>std::arch</code> module allows us to use these kinds of
instructions directly, which means we don’t need to rely on a smart compiler.
Additionally, it includes some features that allow us to choose a particular
implementation based on various criteria. For example:</p>
<pre><code class="language-rust ignore">#[cfg(all(any(target_arch = &quot;x86&quot;, target_arch = &quot;x86_64&quot;),
      target_feature = &quot;avx2&quot;))]
fn foo() {
    #[cfg(target_arch = &quot;x86&quot;)]
    use std::arch::x86::_mm256_add_epi64;
    #[cfg(target_arch = &quot;x86_64&quot;)]
    use std::arch::x86_64::_mm256_add_epi64;

    unsafe {
        _mm256_add_epi64(...);
    }
}
</code></pre>
<p>Here, we use cfg flags to choose the correct version based on the machine
we’re targeting; on x86 we use that version, and on x86_64 we use its
version. We can also choose at runtime:</p>
<pre><code class="language-rust ignore">fn foo() {
    #[cfg(any(target_arch = &quot;x86&quot;, target_arch = &quot;x86_64&quot;))]
    {
        if is_x86_feature_detected!(&quot;avx2&quot;) {
            return unsafe { foo_avx2() };
        }
    }

    foo_fallback();
}
</code></pre>
<p>Here, we have two versions of the function: one which uses AVX2, a specific
kind of SIMD feature that lets you do 256-bit operations. The
<code>is_x86_feature_detected!</code> macro will generate code that detects if your CPU
supports AVX2, and if so, calls the foo_avx2 function. If not, then we fall
back to a non-AVX implementation, foo_fallback. This means that our code will
run super fast on CPUs that support AVX2, but still work on ones that don’t,
albeit slower.</p>
<p>If all of this seems a bit low-level and fiddly, well, it is! <code>std::arch</code> is
specifically primitives for building these kinds of things. We hope to
eventually stabilize a <code>std::simd</code> module with higher-level stuff in the
future. But landing the basics now lets the ecosystem experiment with higher
level libraries starting today. For example, check out the
<a href="https://github.com/AdamNiederer/faster">faster</a> crate. Here’s a code snippet
with no SIMD:</p>
<pre><code class="language-rust ignore">let lots_of_3s = (&amp;[-123.456f32; 128][..]).iter()
    .map(|v| {
        9.0 * v.abs().sqrt().sqrt().recip().ceil().sqrt() - 4.0 - 2.0
    })
    .collect::&lt;Vec&lt;f32&gt;&gt;();
</code></pre>
<p>To use SIMD with this code via faster, you’d change it to this:</p>
<pre><code class="language-rust ignore">let lots_of_3s = (&amp;[-123.456f32; 128][..]).simd_iter()
    .simd_map(f32s(0.0), |v| {
        f32s(9.0) * v.abs().sqrt().rsqrt().ceil().sqrt() - f32s(4.0) - f32s(2.0)
    })
    .scalar_collect();
</code></pre>
<p>It looks almost the same: <code>simd_iter</code> instead of <code>iter</code>, <code>simd_map</code> instead of <code>map</code>,
<code>f32s(2.0)</code> instead of <code>2.0</code>. But you get a SIMD-ified version generated for you.</p>
<p>Beyond that, you may never write any of this yourself, but as always, the
libraries you depend on may. For example, the regex crate contains these SIMD
speedups without you needing to do anything at all!</p>
<a class="header" href="#macros" id="macros"><h1>Macros</h1></a>
<p>In this chapter of the guide, we discuss a few improvements to the macro system.
A notable addition here is the introduction of <a href="custom-derive.html">custom derive macros</a>.</p>
<a class="header" href="#custom-derive" id="custom-derive"><h1>Custom Derive</h1></a>
<p><img src="https://img.shields.io/badge/Minimum%20Rust%20Version-1.15-brightgreen.svg" alt="Minimum Rust version: 1.15" /></p>
<p>In Rust, you’ve always been able to automatically implement some traits
through the derive attribute:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
#[derive(Debug)]
struct Pet {
    name: String,
}
#}</code></pre></pre>
<p>The <code>Debug</code> trait is then implemented for <code>Pet</code>, with vastly less boilerplate. For example, without <code>derive</code>, you'd have
to write this:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use std::fmt;

struct Pet {
    name: String,
}

impl fmt::Debug for Pet {
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter) -&gt; fmt::Result {
        match self {
            Pet { name } =&gt; {
                let mut debug_trait_builder = f.debug_struct(&quot;Pet&quot;);

                let _ = debug_trait_builder.field(&quot;name&quot;, name);

                debug_trait_builder.finish()
            }
        }
    }
}
#}</code></pre></pre>
<p>Whew!</p>
<p>However, this only worked for traits provided as part of the standard
library; it was not customizable. But now, you can tell Rust what to do when
someone wants to derive your trait. This is used heavily in popular crates
like <a href="https://serde.rs/">serde</a> and <a href="http://diesel.rs/">Diesel</a>.</p>
<p>For more, including learning how to build your own custom derive, see <a href="https://doc.rust-lang.org/book/second-edition/appendix-04-macros.html#procedural-macros-for-custom-derive">The
Rust Programming
Language</a>.</p>
<a class="header" href="#macro-changes" id="macro-changes"><h1>Macro changes</h1></a>
<p><img src="https://img.shields.io/badge/Minimum%20Rust%20Version-nightly-red.svg" alt="Minimum Rust version: nightly" /></p>
<p>In Rust 2018, you can import specific macros from external crates via <code>use</code>
statements, rather than the old <code>#[macro_use]</code> attribute.</p>
<p>For example, consider a <code>bar</code> crate that implements a <code>baz!</code> macro. In
<code>src/lib.rs</code>:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
#[macro_export]
macro_rules! baz {
    () =&gt; ()
}
#}</code></pre></pre>
<p>In your crate, you would have written</p>
<pre><code class="language-rust ignore">// Rust 2015

#[macro_use]
extern crate bar;

fn main() {
    baz!();
}
</code></pre>
<p>Now, you write:</p>
<pre><code class="language-rust ignore">// Rust 2018
#![feature(rust_2018_preview)]

use bar::baz;

fn main() {
    baz!();
}
</code></pre>
<p>This moves <code>macro_rules</code> macros to be a bit closer to other kinds of items.</p>
<a class="header" href="#procedural-macros" id="procedural-macros"><h2>Procedural macros</h2></a>
<p>When using procedural macros to derive traits, you will have to name the macro
that provides the custom derive. This generally matches the name of the trait,
but check with the documentation of the crate providing the derives to be sure.</p>
<p>For example, with Serde you would have written</p>
<pre><code class="language-rust ignore">// Rust 2015
extern crate serde;
#[macro_use] extern crate serde_derive;

#[derive(Serialize, Deserialize)]
struct Bar;
</code></pre>
<p>Now, you write instead:</p>
<pre><code class="language-rust ignore">// Rust 2018
#![feature(rust_2018_preview)]
use serde_derive::{Serialize, Deserialize};

#[derive(Serialize, Deserialize)]
struct Bar;
</code></pre>
<a class="header" href="#more-details-8" id="more-details-8"><h2>More details</h2></a>
<p>This only works for macros defined in external crates.
For macros defined locally, <code>#[macro_use] mod foo;</code> is still required, as it was in Rust 2015.</p>
<a class="header" href="#the-compiler" id="the-compiler"><h1>The compiler</h1></a>
<p>In this chapter of the guide, we discuss a few improvements to the compiler.
A notable addition here is our new and <a href="improved-error-messages.html">improved error messages</a>.</p>
<a class="header" href="#improved-error-messages" id="improved-error-messages"><h1>Improved error messages</h1></a>
<p><img src="https://img.shields.io/badge/Minimum%20Rust%20Version-1.12-brightgreen.svg" alt="Minimum Rust version: 1.12" /></p>
<p>We're always working on error improvements, and there are little improvements
in almost every Rust version, but in Rust 1.12, a significant overhaul of the
error message system was created.</p>
<p>For example, here's some code that produces an error:</p>
<pre><code class="language-rust ignore">fn main() {
    let mut x = 5;

    let y = &amp;x;

    x += 1;
}
</code></pre>
<p>Here's the error in Rust 1.11:</p>
<pre><code class="language-text">foo.rs:6:5: 6:11 error: cannot assign to `x` because it is borrowed [E0506]
foo.rs:6     x += 1;
             ^~~~~~
foo.rs:4:14: 4:15 note: borrow of `x` occurs here
foo.rs:4     let y = &amp;x;
                      ^
foo.rs:6:5: 6:11 help: run `rustc --explain E0506` to see a detailed explanation
</code></pre>
<p>Here's the error in Rust 1.28:</p>
<pre><code class="language-text">error[E0506]: cannot assign to `x` because it is borrowed
 --&gt; foo.rs:6:5
  |
4 |     let y = &amp;x;
  |              - borrow of `x` occurs here
5 |
6 |     x += 1;
  |     ^^^^^^ assignment to borrowed `x` occurs here

error: aborting due to previous error
</code></pre>
<p>This error isn't terribly different, but shows off how the format has changed. It shows
off your code in context, rather than just showing the text of the lines themselves.</p>
<a class="header" href="#incremental-compilation" id="incremental-compilation"><h1>Incremental Compilation</h1></a>
<p><img src="https://img.shields.io/badge/Minimum%20Rust%20Version-1.24-brightgreen.svg" alt="Minimum Rust version: 1.24" /></p>
<p>Back in September of 2016, we <a href="https://blog.rust-lang.org/2016/09/08/incremental.html">blogged about Incremental
Compilation</a>. While
that post goes into the details, the idea is basically this: when you’re
working on a project, you often compile it, then change something small, then
compile again. Historically, the compiler has compiled your entire project,
no matter how little you’ve changed the code. The idea with incremental
compilation is that you only need to compile the code you’ve actually
changed, which means that that second build is faster.</p>
<p>This is now turned on by default. This means that your builds should be
faster! Don’t forget about cargo check when trying to get the lowest possible
build times.</p>
<p>This is still not the end story for compiler performance generally, nor
incremental compilation specifically. We have a lot more work planned in the
future.</p>
<p>One small note about this change: it makes builds faster, but makes the final
binary a bit slower. For this reason, it's not turned on in release builds.</p>
<a class="header" href="#an-attribute-for-deprecation" id="an-attribute-for-deprecation"><h1>An attribute for deprecation</h1></a>
<p><img src="https://img.shields.io/badge/Minimum%20Rust%20Version-1.9-brightgreen.svg" alt="Minimum Rust version: 1.9" /></p>
<p>If you're writing a library, and you'd like to deprecate something, you can
use the <code>deprecated</code> attribute:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
#[deprecated(
    since = &quot;0.2.1&quot;,
    note = &quot;Please use the bar function instead&quot;
)]
pub fn foo() {
    // ...
}
#}</code></pre></pre>
<p>This will give your users a warning if they use the deprecated functionality:</p>
<pre><code class="language-text">   Compiling playground v0.0.1 (file:///playground)
warning: use of deprecated item 'foo': Please use the bar function instead
  --&gt; src/main.rs:10:5
   |
10 |     foo();
   |     ^^^
   |
   = note: #[warn(deprecated)] on by default

</code></pre>
<p>Both <code>since</code> and <code>note</code> are optional.</p>
<p><code>since</code> can be in the future; you can put whatever you'd like, and what's put in
there isn't checked.</p>
<a class="header" href="#rustup-for-managing-rust-versions" id="rustup-for-managing-rust-versions"><h1>Rustup for managing Rust versions</h1></a>
<p><img src="https://img.shields.io/badge/Minimum%20Rust%20Version-various-brightgreen.svg" alt="Minimum Rust version: various" /> (this tool has its own versioning scheme and works with all Rust versions)</p>
<p>The <a href="https://rustup.rs/">Rustup</a> tool has become <em>the</em> recommended way to
install Rust, and is advertised on our website. Its powers go further than
that though, allowing you to manage various versions, components, and
platforms.</p>
<a class="header" href="#for-installing-rust" id="for-installing-rust"><h2>For installing Rust</h2></a>
<p>To install Rust through Rustup, you can go to
<a href="https://www.rust-lang.org/install.html">https://www.rust-lang.org/install.html</a>, which will let you know how to do
so on your platform. This will install both <code>rustup</code> itself and the <code>stable</code>
version of <code>rustc</code> and <code>cargo</code>.</p>
<p>To install a specific Rust version, you can use <code>rustup install</code>:</p>
<pre><code class="language-console">$ rustup install 1.30.0
</code></pre>
<p>This works for a specific nightly, as well:</p>
<pre><code class="language-console">$ rustup install nightly-2018-08-01
</code></pre>
<p>As well as any of our release channels:</p>
<pre><code class="language-console">$ rustup install stable
$ rustup install beta
$ rustup install nightly
</code></pre>
<a class="header" href="#for-updating-your-installation" id="for-updating-your-installation"><h2>For updating your installation</h2></a>
<p>To update all of the various channels you may have installed:</p>
<pre><code class="language-console">$ rustup update
</code></pre>
<p>This will look at everything you've installed, and if there are new releases,
will update anything that has one.</p>
<a class="header" href="#managing-versions" id="managing-versions"><h2>Managing versions</h2></a>
<p>To set the default toolchain to something other than <code>stable</code>:</p>
<pre><code class="language-console">$ rustup toolchain default nightly
</code></pre>
<p>To use a toolchain other than the default, use <code>rustup run</code>:</p>
<pre><code class="language-console">$ rustup run nightly cargo build
</code></pre>
<p>There's also an alias for this that's a little shorter:</p>
<pre><code class="language-console">$ cargo +nightly build
</code></pre>
<p>If you'd like to have a different default per-directory, that's easy too!
If you run this inside of a project:</p>
<pre><code class="language-console">$ rustup override set nightly
</code></pre>
<p>Then when you're in that directory, any invocations of <code>rustc</code> or <code>cargo</code>
will use that toolchain. To share this with others, you can create a
<code>rust-toolchain</code> file with the contents of a toolchain, and check it into
source control. Now, when someone clones your project, they'll get the
right version without needing to <code>override set</code> themselves.</p>
<a class="header" href="#installing-other-targets" id="installing-other-targets"><h2>Installing other targets</h2></a>
<p>Rust supports cross-compiling to other targets, and Rustup can help you
manage them. For example, to use MUSL:</p>
<pre><code class="language-console">$ rustup target add x86_64-unknown-linux-musl
</code></pre>
<p>And then you can</p>
<pre><code class="language-console">$ cargo build --target=x86_64-unknown-linux-musl
</code></pre>
<p>To see the full list of targets you can install:</p>
<pre><code class="language-console">$ rustup target list
</code></pre>
<a class="header" href="#installing-components" id="installing-components"><h2>Installing components</h2></a>
<p>Components are used to install certain kinds of tools. While <code>cargo-install</code>
has you covered for most tools, some tools need deep integration into the
compiler. Rustup knows exactly what version of the compiler you're using, and
so it's got just the information that these tools need.</p>
<p>Components are per-toolchain, so if you want them to be available to more
than one toolchain, you'll need to install them multiple times. In the
following examples, add a <code>--toolchain</code> flag, set to the toolchain you
want to install for, <code>nightly</code> for example. Without this flag, it will
install the component for the default toolchain.</p>
<p>To see the full list of components you can install:</p>
<pre><code class="language-console">$ rustup component list
</code></pre>
<p>Next, let's talk about some popular components and when you might want to
install them.</p>
<a class="header" href="#rust-docs-for-local-documentation" id="rust-docs-for-local-documentation"><h3><code>rust-docs</code>, for local documentation</h3></a>
<p>This first component is installed by default when you install a toolchain. It
contains a copy of Rust's documentation, so that you can read it offline.</p>
<p>This component cannot be removed for now; if that's of interest, please
comment on <a href="https://github.com/rust-lang-nursery/rustup.rs/issues/998">this
issue</a>.</p>
<a class="header" href="#rust-src-for-a-copy-of-rusts-source-code" id="rust-src-for-a-copy-of-rusts-source-code"><h3><code>rust-src</code> for a copy of Rust's source code</h3></a>
<p>The <code>rust-src</code> component can give you a local copy of Rust's source code. Why
might you need this? Well, autocompletion tools like Racer use this
information to know more about the functions you're trying to call.</p>
<pre><code class="language-console">$ rustup component add rust-src
</code></pre>
<a class="header" href="#the-preview-components" id="the-preview-components"><h3>The &quot;preview&quot; components</h3></a>
<p>There are several components in a &quot;preview&quot; stage. These components currently
have <code>-preview</code> in their name, and this indicates that they're not quite 100%
ready for general consumption yet. Please try them out and give us feedback,
but know that they do not follow Rust's stability guarantees, and are still
actively changing, possibly in backwards-incompatible ways.</p>
<a class="header" href="#rustfmt-preview-for-automatic-code-formatting" id="rustfmt-preview-for-automatic-code-formatting"><h4><code>rustfmt-preview</code> for automatic code formatting</h4></a>
<p><img src="https://img.shields.io/badge/Minimum%20Rust%20Version-1.24-brightgreen.svg" alt="Minimum Rust version: 1.24" /></p>
<p>If you'd like to have your code automatically formatted, you can
install this component:</p>
<pre><code class="language-console">$ rustup component add rustfmt-preview
</code></pre>
<p>This will install two tools, <code>rustfmt</code> and <code>cargo-fmt</code>, that will reformat your
code for you! For example:</p>
<pre><code class="language-console">$ cargo fmt
</code></pre>
<p>will reformat your entire Cargo project.</p>
<a class="header" href="#rls-preview-for-ide-integration" id="rls-preview-for-ide-integration"><h4><code>rls-preview</code> for IDE integration</h4></a>
<p><img src="https://img.shields.io/badge/Minimum%20Rust%20Version-1.21-brightgreen.svg" alt="Minimum Rust version: 1.21" /></p>
<p>Many IDE features are built off of the <a href="http://langserver.org/"><code>langserver</code>
protocol</a>. To gain support for Rust with these IDEs,
you'll need to install the Rust language sever, aka the &quot;RLS&quot;:</p>
<pre><code class="language-console">$ rustup component add rls-preview
</code></pre>
<p>Your IDE should take it from there.</p>
<a class="header" href="#clippy-preview-for-more-lints" id="clippy-preview-for-more-lints"><h4><code>clippy-preview</code> for more lints</h4></a>
<p>For even more lints to help you write Rust code, you can install <code>clippy</code>:</p>
<pre><code class="language-console">$ rustup component add clippy-preview
</code></pre>
<p>This will install <code>cargo-clippy</code> for you:</p>
<pre><code class="language-console">$ cargo clippy
</code></pre>
<p>For more, check out <a href="https://github.com/rust-lang-nursery/rust-clippy">clippy's
documentation</a>.</p>
<a class="header" href="#llvm-tools-preview-for-using-extra-llvm-tools" id="llvm-tools-preview-for-using-extra-llvm-tools"><h4><code>llvm-tools-preview</code> for using extra LLVM tools</h4></a>
<p>If you'd like to use the <code>lld</code> linker, or other tools like <code>llvm-objdump</code> or
<code>llvm-objcopy</code>, you can install this component:</p>
<pre><code class="language-console">$ rustup component add llvm-tools-preview
</code></pre>
<p>This is the newest component, and so doesn't have good documentation at the
moment.</p>
<a class="header" href="#cargo-and-cratesio" id="cargo-and-cratesio"><h1>Cargo and crates.io</h1></a>
<p>In this chapter of the guide, we discuss a few improvements to <code>cargo</code> and crates.io.
A notable addition here is the new <a href="improved-error-messages.html"><code>cargo check</code></a> command.</p>
<a class="header" href="#cargo-check-for-faster-checking" id="cargo-check-for-faster-checking"><h1><code>cargo check</code> for faster checking</h1></a>
<p><img src="https://img.shields.io/badge/Minimum%20Rust%20Version-1.16-brightgreen.svg" alt="Minimum Rust version: 1.16" /></p>
<p><code>cargo check</code> is a new subcommand should speed up the development
workflow in many cases.</p>
<p>What does it do? Let's take a step back and talk about how <code>rustc</code> compiles
your code. Compilation has many &quot;passes&quot;, that is, there are many distinct
steps that the compiler takes on the road from your source code to producing
the final binary. However, you can think of this process in two big steps:
first, <code>rustc</code> does all of its safety checks, makes sure your syntax is
correct, all that stuff. Second, once it's satisfied that everything is in
order, it produces the actual binary code that you end up executing.</p>
<p>It turns out that that second step takes a lot of time. And most of the time,
it's not neccesary. That is, when you're working on some Rust code, many
developers will get into a workflow like this:</p>
<ol>
<li>Write some code.</li>
<li>Run <code>cargo build</code> to make sure it compiles.</li>
<li>Repeat 1-2 as needed.</li>
<li>Run <code>cargo test</code> to make sure your tests pass.</li>
<li>Try the binary yourself</li>
<li>GOTO 1.</li>
</ol>
<p>In step two, you never actually run your code. You're looking for feedback
from the compiler, not to actually run the binary. <code>cargo check</code> supports
exactly this use-case: it runs all of the compiler's checks, but doesn't
produce the final binary. To use it:</p>
<pre><code class="language-console">$ cargo check
</code></pre>
<p>where you may normally <code>cargo build</code>. The workflow now looks like:</p>
<ol>
<li>Write some code.</li>
<li>Run <code>cargo check</code> to make sure it compiles.</li>
<li>Repeat 1-2 as needed.</li>
<li>Run <code>cargo test</code> to make sure your tests pass.</li>
<li>Run <code>cargo build</code> to build a binary and try it yourself</li>
<li>GOTO 1.</li>
</ol>
<p>So how much speedup do you actually get? Like most performance related
questions, the answer is &quot;it depends.&quot; Here are some very un-scientific
benchmarks at the time of writing.</p>
<table><thead><tr><th>  build </th><th> performance </th><th> check performance </th><th> speedup </th></tr></thead><tbody>
<tr><td> initial compile </td><td> 11s </td><td> 5.6s </td><td> 1.96x </td></tr>
<tr><td> second compile (no changes) </td><td> 3s </td><td> 1.9s </td><td> 1.57x </td></tr>
<tr><td> third compile with small change </td><td> 5.8s </td><td> 3s </td><td> 1.93x </td></tr>
</tbody></table>
<a class="header" href="#cargo-install-for-easy-installation-of-tools" id="cargo-install-for-easy-installation-of-tools"><h1><code>cargo install</code> for easy installation of tools</h1></a>
<p><img src="https://img.shields.io/badge/Minimum%20Rust%20Version-1.5-brightgreen.svg" alt="Minimum Rust version: 1.5" /></p>
<p>Cargo has grown a new <code>install</code> command. This is intended to be used for installing
new subcommands for Cargo, or tools for Rust developers. This doesn't replace the need
to build real, native packages for end-users on the platforms you support.</p>
<p>For example, this guide is created with <a href="https://crates.io/crates/mdbook"><code>mdbook</code></a>. You
can install it on your system with</p>
<pre><code class="language-console">$ cargo install mdbook
</code></pre>
<p>And then use it with</p>
<pre><code class="language-console">$ mdbook --help
</code></pre>
<p>As an example of extending Cargo, you can use the <a href="https://crates.io/crates/cargo-update"><code>cargo-update</code></a>
package. To install it:</p>
<pre><code class="language-console">$ cargo install cargo-update
</code></pre>
<p>This will allow you to use this command, which checks everything you've <code>cargo install</code>'d and
updates it to the latest version:</p>
<pre><code class="language-console">$ cargo install-update -a
</code></pre>
<a class="header" href="#cargo-new-defaults-to-a-binary-project" id="cargo-new-defaults-to-a-binary-project"><h1><code>cargo new</code> defaults to a binary project</h1></a>
<p><img src="https://img.shields.io/badge/Minimum%20Rust%20Version-1.25-brightgreen.svg" alt="Minimum Rust version: 1.25" /></p>
<p><code>cargo new</code> will now default to generating a binary, rather than a library.
We try to keep Cargo’s CLI quite stable, but this change is important, and is
unlikely to cause breakage.</p>
<p>For some background, cargo new accepts two flags: <code>--lib</code>, for creating
libraries, and <code>--bin</code>, for creating binaries, or executables. If you don’t
pass one of these flags, it used to default to <code>--lib</code>. At the time, we made
this decision because each binary (often) depends on many libraries, and so
we thought the library case would be more common. However, this is incorrect;
each library is depended upon by many binaries. Furthermore, when getting
started, what you often want is a program you can run and play around with.
It’s not just new Rustaceans though; even very long-time community members
have said that they find this default surprising. As such, we’ve changed it,
and it now defaults to <code>--bin</code>.</p>
<a class="header" href="#cargo-rustc-for-passing-arbitrary-flags-to-rustc" id="cargo-rustc-for-passing-arbitrary-flags-to-rustc"><h1><code>cargo rustc</code> for passing arbitrary flags to rustc</h1></a>
<p><img src="https://img.shields.io/badge/Minimum%20Rust%20Version-1.1-brightgreen.svg" alt="Minimum Rust version: 1.1" /></p>
<p><code>cargo rustc</code> is a new subcommand for Cargo that allows you to pass arbitrary
<code>rustc</code> flags through Cargo.</p>
<p>For example, Cargo does not have a way to pass unstable flags built-in. But
if we'd like to use <code>print-type-sizes</code> to see what layout information our
types have. We can run this:</p>
<pre><code class="language-console">$ cargo rustc -- -Z print-type-sizes
</code></pre>
<p>And we'll get a bunch of output describing the size of our types.</p>
<a class="header" href="#note" id="note"><h2>Note</h2></a>
<p><code>cargo rustc</code> only passes these flags to invocations of your crate, and not to any <code>rustc</code>
invocations used to build dependencies. If you'd like to do that, see <code>$RUSTFLAGS</code>.</p>
<a class="header" href="#cargo-workspaces-for-multi-package-projects" id="cargo-workspaces-for-multi-package-projects"><h1>Cargo workspaces for multi-package projects</h1></a>
<p><img src="https://img.shields.io/badge/Minimum%20Rust%20Version-1.12-brightgreen.svg" alt="Minimum Rust version: 1.12" /></p>
<p>Cargo used to have two levels of organization:</p>
<ul>
<li>A <em>package</em> contains one or more crates</li>
<li>A crate has one or more modules</li>
</ul>
<p>Cargo now has an additional level:</p>
<ul>
<li>A <em>workspace</em> contains one or more packages</li>
</ul>
<p>This can be useful for larger projects. For example, [the <code>futures</code>
respository] is a <em>workspace</em> that contains many related packages:</p>
<ul>
<li>futures</li>
<li>futures-util</li>
<li>futures-io</li>
<li>futures-channel</li>
</ul>
<p>and more.</p>
<p>Workspaces allow these packages to be developed individually, but they share
a single set of dependencies, and therefore have a single target directory
and a single <code>Cargo.lock</code>.</p>
<p>For more details about workspaces, please see <a href="https://doc.rust-lang.org/stable/cargo/reference/manifest.html#the-workspace-section">the Cargo documentation</a>.</p>
<a class="header" href="#multi-file-examples" id="multi-file-examples"><h1>Multi-file examples</h1></a>
<p><img src="https://img.shields.io/badge/Minimum%20Rust%20Version-1.22-brightgreen.svg" alt="Minimum Rust version: 1.22" /></p>
<p>Cargo has an <code>examples</code> feature for showing people how to use your package.
By putting individual files inside of the top-level <code>examples</code> directory, you
can create multiple examples.</p>
<p>But what if your example is too big for a single file? Cargo supports adding
sub-directories inside of <code>examples</code>, and looks for a <code>main.rs</code> inside of
them to build the example. It looks like this:</p>
<pre><code class="language-text">my-package
 └──src
     └── lib.rs // code here
 └──examples 
     └── simple-example.rs // a single-file example
     └── complex-example
        └── helper.rs
        └── main.rs // a more complex example that also uses `helper` as a submodule
</code></pre>
<a class="header" href="#replacing-dependencies-with-patch" id="replacing-dependencies-with-patch"><h1>Replacing dependencies with patch</h1></a>
<p><img src="https://img.shields.io/badge/Minimum%20Rust%20Version-1.21-brightgreen.svg" alt="Minimum Rust version: 1.21" /></p>
<p>The <code>[patch]</code> section of your <code>Cargo.toml</code> can be used when you want to
override certain parts of your dependency graph.</p>
<blockquote>
<p>Cargo has a <code>[replace]</code> feature that is similar; while we don't intend to deprecate
or remove <code>[replace]</code>, you should prefer <code>[patch]</code> in all circumstances.</p>
</blockquote>
<p>So what’s it look like? Let’s say we have a Cargo.toml that looks like this:</p>
<pre><code class="language-toml">[dependencies]
foo = &quot;1.2.3&quot;
</code></pre>
<p>In addition, our <code>foo</code> package depends on a <code>bar</code> crate, and we find a bug in <code>bar</code>.
To test this out, we’d download the source code for <code>bar</code>, and then update our
<code>Cargo.toml</code>:</p>
<pre><code class="language-toml">[dependencies]
foo = &quot;1.2.3&quot;

[patch.crates-io]
bar = { path = '/path/to/bar' }
</code></pre>
<p>Now, when you <code>cargo build</code>, it will use the local version of <code>bar</code>, rather
than the one from crates.io that <code>foo</code> depends on. You can then try out your
changes, and fix that bug!</p>
<p>For more details, see <a href="https://doc.rust-lang.org/cargo/reference/manifest.html#the-patch-section">the documentation for
<code>patch</code></a>.</p>
<a class="header" href="#cargo-can-use-a-local-registry-replacement" id="cargo-can-use-a-local-registry-replacement"><h1>Cargo can use a local registry replacement</h1></a>
<p><img src="https://img.shields.io/badge/Minimum%20Rust%20Version-1.12-brightgreen.svg" alt="Minimum Rust version: 1.12" /></p>
<p>Cargo finds its packages in a &quot;source&quot;. The default source is <a href="https://crates.io">crates.io</a>. However, you
can choose a different source in your <code>.cargo/config</code>:</p>
<pre><code class="language-toml">[source.crates-io]
replace-with = 'my-awesome-registry'

[source.my-awesome-registry]
registry = 'https://github.com/my-awesome/registry-index'
</code></pre>
<p>This configuration means that instead of using crates.io, Cargo will query
the <code>my-awesome-registry</code> source instead (configured to a different index
here). This alternate source <em>must be the exact same</em> as the crates.io index.
Cargo assumes that replacement sources are exact 1:1 mirrors in this respect,
and the following support is designed around that assumption.</p>
<p>When generating a lock file for crate using a replacement registry, the
original registry will be encoded into the lock file. For example in the
configuration above, all lock files will still mention crates.io as the
registry that packages originated from. This semantically represents how
crates.io is the source of truth for all crates, and this is upheld because
all replacements have a 1:1 correspondance.</p>
<p>Overall, this means that no matter what replacement source you're working
with, you can ship your lock file to anyone else and you'll all still have
verifiably reproducible builds!</p>
<p>This has enabled tools like
<a href="https://github.com/alexcrichton/cargo-vendor"><code>cargo-vendor</code></a> and
<a href="https://github.com/alexcrichton/cargo-local-registry"><code>cargo-local-registry</code></a>,
which are often useful for &quot;offline builds.&quot; They prepare the list of all
Rust dependencies ahead of time, which lets you ship them to a build machine
with ease.</p>
<a class="header" href="#cratesio-disallows-wildcard-dependencies" id="cratesio-disallows-wildcard-dependencies"><h1>Crates.io disallows wildcard dependencies</h1></a>
<p><img src="https://img.shields.io/badge/Minimum%20Rust%20Version-1.6-brightgreen.svg" alt="Minimum Rust version: 1.6" /></p>
<p>Crates.io will not allow you to upload a package with a wildcard dependency.
In other words, these:</p>
<pre><code class="language-toml">[dependencies]
regex = &quot;*&quot;
</code></pre>
<p>A wildcard dependency means that you work with any possible version of your
dependency. This is highly unlikely to be true, and would cause unnecessary
breakage in the ecosystem.</p>
<p>Instead, depend on a version range. For example, <code>^</code> is the default, so
you could use</p>
<pre><code class="language-toml">[dependencies]
regex = &quot;1.0.0&quot;
</code></pre>
<p>instead. <code>&gt;</code>, <code>&lt;=</code>, and all of the other, non-<code>*</code> ranges work as well.</p>
<a class="header" href="#documentation" id="documentation"><h1>Documentation</h1></a>
<p>In this chapter of the guide, we discuss a few improvements to documentation.
A notable addition here is the <a href="new-editions-of-the-book.html">second edition of &quot;the book&quot;</a>.</p>
<a class="header" href="#new-editions-of-the-the-book" id="new-editions-of-the-the-book"><h1>New editions of the &quot;the book&quot;</h1></a>
<p><img src="https://img.shields.io/badge/Minimum%20Rust%20Version-1.18-red.svg" alt="Minimum Rust version: 1.18" /> for drafts of the second edition</p>
<p><img src="https://img.shields.io/badge/Minimum%20Rust%20Version-1.26-brightgreen.svg" alt="Minimum Rust version: 1.26" /> for the final version of the second edition</p>
<p><img src="https://img.shields.io/badge/Minimum%20Rust%20Version-1.28-red.svg" alt="Minimum Rust version: 1.28" /> for drafts of the 2018 edition</p>
<p>We've distributed a copy of &quot;The Rust Programming Language,&quot; affectionately
nicknamed &quot;the book&quot;, with every version of Rust since Rust 1.0.</p>
<p>However, because it was written before Rust 1.0, it started showing its age.
Many parts of the book are vague, because it was written before the true
details were nailed down for the 1.0 release. It didn't do a fantastic job of
teaching lifetimes.</p>
<p>Starting with Rust 1.18, we shipped drafts of a second edition of the book.
The final version was shipped with Rust 1.26. The new edition is a complete
re-write from the ground up, using the last two years of knowledge we’ve
gained from teaching people Rust. You’ll find brand-new explanations for a
lot of Rust’s core concepts, new projects to build, and all kinds of other
good stuff. Please <a href="https://doc.rust-lang.org/book/second-edition/index.html">check it
out</a> and let us
know what you think!</p>
<p>You can also purchase <a href="https://nostarch.com/Rust">a dead-tree version from No Starch
Press</a>. Now that the print version has shipped,
the second edition is frozen.</p>
<p>The names are a bit confusing though, because the &quot;second edition&quot; of the
book is the first printed edition of the book. As such, we decided that newer
editions of the book will correspond with newer editions of Rust itself, and
so starting with 1.28, we've been shipping drafts of the next version, <a href="https://doc.rust-lang.org/book/2018-edition/index.html">the
2018 Edition</a>. It's
still pretty close to the second edition, but contains information about
newer features since the book's content was frozen. We'll be continuing to
update this edition until we decide to print a second edition in paper.</p>
<a class="header" href="#the-rust-bookshelf" id="the-rust-bookshelf"><h1>The Rust Bookshelf</h1></a>
<p><img src="https://img.shields.io/badge/Minimum%20Rust%20Version-various-brightgreen.svg" alt="Minimum Rust version: various" />, each book is different.</p>
<p>As Rust's documentation has grown, we've gained far more than just &quot;The book&quot;
and the reference. We now have a collection of various long-form docs,
nicknamed &quot;the Rust Bookshelf.&quot; Different resources are added at various
times, and we're adding new ones as more get written.</p>
<a class="header" href="#the-cargo-book" id="the-cargo-book"><h2>The Cargo book</h2></a>
<p><img src="https://img.shields.io/badge/Minimum%20Rust%20Version-1.21-brightgreen.svg" alt="Minimum Rust version: 1.21" /></p>
<p>Historically, Cargo’s docs were hosted on <a href="http://doc.crates.io">http://doc.crates.io</a>, which
doesn’t follow the release train model, even though Cargo itself does. This
led to situations where a feature would land in Cargo nightly, the docs would
be updated, and then for up to twelve weeks, users would think that it should
work, but it wouldn’t yet. <a href="https://doc.rust-lang.org/cargo">https://doc.rust-lang.org/cargo</a> is the new home
of Cargo’s docs, and <a href="http://doc.crates.io">http://doc.crates.io</a> now redirects there.</p>
<a class="header" href="#the-rustdoc-book" id="the-rustdoc-book"><h2>The <code>rustdoc</code> book</h2></a>
<p><img src="https://img.shields.io/badge/Minimum%20Rust%20Version-1.21-brightgreen.svg" alt="Minimum Rust version: 1.21" /></p>
<p>Rustdoc, our documentation tool, now has a guide at <a href="https://doc.rust-lang.org/rustdoc">https://doc.rust-lang.org/rustdoc</a>.</p>
<a class="header" href="#rust-by-example" id="rust-by-example"><h2>Rust By Example</h2></a>
<p><img src="https://img.shields.io/badge/Minimum%20Rust%20Version-1.25-brightgreen.svg" alt="Minimum Rust version: 1.25" /></p>
<p>Rust by Example used to live at <a href="https://rustbyexample.com">https://rustbyexample.com</a>, but now is part of the Bookshelf!
It can be found at <a href="https://doc.rust-lang.org/rust-by-example/">https://doc.rust-lang.org/rust-by-example/</a>. RBE lets you learn Rust through
short code examples and exercises, as opposed to the lengthy prose of The Book.</p>
<a class="header" href="#the-rustonomicon" id="the-rustonomicon"><h1>The Rustonomicon</h1></a>
<p><img src="https://img.shields.io/badge/Minimum%20Rust%20Version-1.3-brightgreen.svg" alt="Minimum Rust version: 1.3" /></p>
<p>We now have a draft book, <a href="https://doc.rust-lang.org/stable/nomicon/">The Rustonomicon: the Dark Arts of Advanced and
Unsafe Rust Programming</a>.</p>
<p>From the title, I'm sure you can guess: this book discusses some advanced
topics, including <code>unsafe</code>. It's a must-read for anyone who's working at the
lowest levels with Rust.</p>
<a class="header" href="#stdos-has-documentation-for-all-platforms" id="stdos-has-documentation-for-all-platforms"><h1><code>std::os</code> has documentation for all platforms</h1></a>
<p><img src="https://img.shields.io/badge/Minimum%20Rust%20Version-1.21-brightgreen.svg" alt="Minimum Rust version: 1.21" /></p>
<p>The <code>std::os</code> module contains operating system specific functionality. You’ll
now see more than just linux, the platform we build the documentation on.</p>
<p>We’ve long regretted that the hosted version of the documentation has been
Linux-specific; this is a first step towards rectifying that. This is
specific to the standard library and not for general use; we hope to improve
this further in the future.</p>
<a class="header" href="#rustdoc" id="rustdoc"><h1><code>rustdoc</code></h1></a>
<p>In this chapter of the guide, we discuss a few improvements to <code>rustdoc</code>.
A notable addition to it was <a href="documentation-tests-can-now-compile-fail.html">that documentation tests can now compile-fail</a>.</p>
<a class="header" href="#documentation-tests-can-now-compile-fail" id="documentation-tests-can-now-compile-fail"><h1>Documentation tests can now compile-fail</h1></a>
<p><img src="https://img.shields.io/badge/Minimum%20Rust%20Version-1.22-brightgreen.svg" alt="Minimum Rust version: 1.22" /></p>
<p>You can now create <code>compile-fail</code> tests in Rustdoc, like this:</p>
<pre><code>/// ```compile_fail
/// let x = 5;
/// x += 2; // shouldn't compile!
/// ```
# fn foo() {}
</code></pre>
<p>Please note that these kinds of tests can be more fragile than others, as
additions to Rust may cause code to compile when it previously would not.
Consider the first release with <code>?</code>, for example: code using <code>?</code> would fail
to compile on Rust 1.21, but compile successfully on Rust 1.22, causing your
test suite to start failing.</p>
<a class="header" href="#rustdoc-uses-commonmark" id="rustdoc-uses-commonmark"><h1>Rustdoc uses CommonMark</h1></a>
<p><img src="https://img.shields.io/badge/Minimum%20Rust%20Version-1.25-brightgreen.svg" alt="Minimum Rust version: 1.25" /> for support by default</p>
<p><img src="https://img.shields.io/badge/Minimum%20Rust%20Version-1.23-red.svg" alt="Minimum Rust version: 1.23" /> for support via a flag</p>
<p>Rustdoc lets you write documentation comments in Markdown. At Rust 1.0, we
were using the <code>hoedown</code> markdown implementation, written in C. Markdown is
more of a family of implementations of an idea, and so <code>hoedown</code> had its own
dialect, like many parsers. The <a href="https://commonmark.org/">CommonMark project</a>
has attempted to define a more strict version of Markdown, and so now, Rustdoc
uses it by default.</p>
<p>As of Rust 1.23, we still defaulted to <code>hoedown</code>, but you could enable
Commonmark via a flag, <code>--enable-commonmark</code>. Today, we only support
CommonMark.</p>
<a class="header" href="#platform-and-target-support" id="platform-and-target-support"><h1>Platform and target support</h1></a>
<p>In this chapter of the guide, we discuss a few improvements to platform and target support.
A notable addition to it was <a href="libcore-for-low-level-rust.html">that the <code>libcore</code> library now works on stable Rust</a>.</p>
<a class="header" href="#libcore-for-low-level-rust" id="libcore-for-low-level-rust"><h1>libcore for low-level Rust</h1></a>
<p><img src="https://img.shields.io/badge/Minimum%20Rust%20Version-1.6-brightgreen.svg" alt="Minimum Rust version: 1.6" /></p>
<p>Rust’s standard library is two-tiered: there’s a small core library,
<code>libcore</code>, and the full standard library, <code>libstd</code>, that builds on top of it.
<code>libcore</code> is completely platform agnostic, and requires only a handful of
external symbols to be defined. Rust’s <code>libstd</code> builds on top of <code>libcore</code>,
adding support for things like memory allocation and I/O. Applications using
Rust in the embedded space, as well as those writing operating systems, often
eschew <code>libstd</code>, using only <code>libcore</code>.</p>
<p>As an additional note, while building <em>libraries</em> with <code>libcore</code> is supported
today, building full applications is not yet stable.</p>
<p>To use <code>libcore</code>, add this flag to your crate root:</p>
<pre><code class="language-rust ignore">#![no_std]
</code></pre>
<p>This will remove the standard library, and bring the <code>core</code> crate into your
namespace for use:</p>
<pre><code class="language-rust ignore">#![no_std]

use core::cell::Cell;
</code></pre>
<p>You can find <code>libcore</code>'s documentation <a href="https://doc.rust-lang.org/core/">here</a>.</p>
<a class="header" href="#webassembly-support" id="webassembly-support"><h1>WebAssembly support</h1></a>
<p><img src="https://img.shields.io/badge/Minimum%20Rust%20Version-1.14-brightgreen.svg" alt="Minimum Rust version: 1.14" /> for <code>emscripten</code></p>
<p><img src="https://img.shields.io/badge/Minimum%20Rust%20Version-nightly-red.svg" alt="Minimum Rust version: nightly" /> for <code>wasm32-unknown-unknown</code></p>
<p>Rust has gained support for <a href="https://webassembly.org/">WebAssembly</a>, meaning
that you can run Rust code in your browser, client-side.</p>
<p>In Rust 1.14, we gained support through
<a href="http://kripken.github.io/emscripten-site/index.html">emscripten</a>. With it
installed, you can write Rust code and have it produce
<a href="http://asmjs.org/">asm.js</a> (the precusor to wasm) and/or WebAssembly.</p>
<p>Here's an example of using this support:</p>
<pre><code class="language-console">$ rustup target add wasm32-unknown-emscripten
$ echo 'fn main() { println!(&quot;Hello, Emscripten!&quot;); }' &gt; hello.rs
$ rustc --target=wasm32-unknown-emscripten hello.rs
$ node hello.js
</code></pre>
<p>However, in the meantime, Rust has also grown its own support, independent
from Emscripten. This is known as &quot;the unknown target&quot;, because instead of
<code>wasm32-unknown-emscripten</code>, it's <code>wasm32-unknown-unknown</code>. This will be
the preferred target to use once it's ready, but for now, it's really
only well-supported in nightly.</p>
<a class="header" href="#global-allocators" id="global-allocators"><h1>Global allocators</h1></a>
<p><img src="https://img.shields.io/badge/Minimum%20Rust%20Version-1.28-brightgreen.svg" alt="Minimum Rust version: 1.28" /></p>
<p>Allocators are the way that programs in Rust obtain memory from the system at
runtime. Previously, Rust did not allow changing the way memory is obtained,
which prevented some use cases. On some platforms, this meant using jemalloc,
on others, the system allocator, but there was no way for users to control
this key component. With 1.28.0, the <code>#[global_allocator]</code> attribute is now
stable, which allows Rust programs to set their allocator to the system
allocator, as well as define new allocators by implementing the <code>GlobalAlloc</code>
trait.</p>
<p>The default allocator for Rust programs on some platforms is jemalloc. The
standard library now provides a handle to the system allocator, which can be
used to switch to the system allocator when desired, by declaring a static
and marking it with the <code>#[global_allocator]</code> attribute.</p>
<pre><pre class="playpen"><code class="language-rust">use std::alloc::System;

#[global_allocator]
static GLOBAL: System = System;

fn main() {
    let mut v = Vec::new();
    // This will allocate memory using the system allocator.
    v.push(1);
}
</code></pre></pre>
<p>However, sometimes you want to define a custom allocator for a given
application domain. This is also relatively easy to do by implementing the
<code>GlobalAlloc</code> trait. You can read more about how to do this in <a href="https://doc.rust-lang.org/std/alloc/trait.GlobalAlloc.html">the
documentation</a>.</p>
<a class="header" href="#msvc-toolchain-support" id="msvc-toolchain-support"><h1>MSVC toolchain support</h1></a>
<p><img src="https://img.shields.io/badge/Minimum%20Rust%20Version-1.2-brightgreen.svg" alt="Minimum Rust version: 1.2" /></p>
<p>At the release of Rust 1.0, we only supported the GNU toolchain on Windows. With the
release of Rust 1.2, we introduced initial support for the MSVC toolchain. After that,
as support matured, we eventually made it the default choice for Windows users.</p>
<p>The difference between the two matters for interacting with C. If you're using a library
built with one toolchain or another, you need to match that with the appropriate Rust
toolchain. If you're not sure, go with MSVC; it's the default for good reason.</p>
<p>To use this feature, simply use Rust on Windows, and the installer will default to it.
If you'd prefer to switch to the GNU toolchain, you can install it with Rustup:</p>
<pre><code class="language-console">$ rustup toolchain install stable-x86_64-pc-windows-gnu
</code></pre>
<a class="header" href="#musl-support-for-fully-static-binaries" id="musl-support-for-fully-static-binaries"><h1>MUSL support for fully static binaries</h1></a>
<p><img src="https://img.shields.io/badge/Minimum%20Rust%20Version-1.1-brightgreen.svg" alt="Minimum Rust version: 1.1" /></p>
<p>By default, Rust will statically link all Rust code. However, if you use the
standard library, it will dynamically link to the system's <code>libc</code>
implementation.</p>
<p>If you'd like a 100% static binary, the <a href="https://www.musl-libc.org/"><code>MUSL libc</code></a> can be used on Linux.</p>
<a class="header" href="#installing-musl-support" id="installing-musl-support"><h2>Installing MUSL support</h2></a>
<p>To add support for MUSL, you need to choose the correct target. <a href="https://forge.rust-lang.org/platform-support.html">The forge
has a full list of
targets</a> supported,
with a number of ones using <code>musl</code>.</p>
<p>If you're not sure what you want, it's probably <code>x86_64-unknown-linux-musl</code>,
for 64-bit Linux. We'll be using this target in this guide, but the
instructions remain the same for other targets, just change the name wherever
we mention the target.</p>
<p>To get support for this target, you use <code>rustup</code>:</p>
<pre><code class="language-console">$ rustup target add x86_64-unknown-linux-musl
</code></pre>
<p>This will install support for the default toolchain; to install for other toolchains,
add the <code>--toolchain</code> flag. For example:</p>
<pre><code class="language-console">$ rustup target add x86_64-unknown-linux-musl --toolchain=nightly
</code></pre>
<a class="header" href="#building-with-musl" id="building-with-musl"><h2>Building with MUSL</h2></a>
<p>To use this new target, pass the <code>--target</code> flag to Cargo:</p>
<pre><code class="language-console">$ cargo build --target x86_64-unknown-linux-musl
</code></pre>
<p>The binary produced will now be built with MUSL!</p>
<a class="header" href="#cdylib-crates-for-c-interoperability" id="cdylib-crates-for-c-interoperability"><h1>cdylib crates for C interoperability</h1></a>
<p><img src="https://img.shields.io/badge/Minimum%20Rust%20Version-1.10-brightgreen.svg" alt="Minimum Rust version: 1.10" /> for <code>rustc</code></p>
<p><img src="https://img.shields.io/badge/Minimum%20Rust%20Version-1.11-brightgreen.svg" alt="Minimum Rust version: 1.11" /> for <code>cargo</code></p>
<p>If you're producing a library that you intend to be used from C (or another
language through a C FFI), there's no need for Rust to include Rust-specific
stuff in the final object code. For libraries like that, you'll want to use
the <code>cdylib</code> crate type in your <code>Cargo.toml</code>:</p>
<pre><code class="language-toml">[lib]
crate-type = [&quot;cdylib&quot;]
</code></pre>
<p>This will produce a smaller binary, with no Rust-specific information insde
of it.</p>
<a class="header" href="#unstable-feature-status" id="unstable-feature-status"><h1>Unstable feature status</h1></a>
<a class="header" href="#language" id="language"><h2>Language</h2></a>
<table><thead><tr><th> <strong>Feature</strong> </th><th> <strong>Status</strong> </th><th> <strong>Minimum Edition</strong> </th></tr></thead><tbody>
<tr><td> <a href="rust-2018/trait-system/impl-trait-for-returning-complex-types-with-ease.html"><code>impl Trait</code></a> </td><td> <a href="https://blog.rust-lang.org/2018/05/10/Rust-1.26.html">Shipped, 1.26</a> </td><td> 2015 </td></tr>
<tr><td> <a href="rust-2018/slice-patterns.html">Basic slice patterns</a> </td><td> <a href="https://blog.rust-lang.org/2018/05/10/Rust-1.26.html">Shipped, 1.26</a> </td><td> 2015 </td></tr>
<tr><td> <a href="rust-2018/ownership-and-lifetimes/default-match-bindings.html">Default match bindings</a> </td><td> <a href="https://blog.rust-lang.org/2018/05/10/Rust-1.26.html">Shipped, 1.26</a> </td><td> 2015 </td></tr>
<tr><td> <a href="rust-2018/ownership-and-lifetimes/the-anonymous-lifetime.html">Anonymous lifetimes</a> </td><td> <a href="https://github.com/rust-lang/rust/blob/master/RELEASES.md#version-1260-2018-05-10">Shipped, 1.26</a> </td><td> 2015 </td></tr>
<tr><td> <a href="rust-2018/trait-system/dyn-trait-for-trait-objects.html"><code>dyn Trait</code></a> </td><td> <a href="https://blog.rust-lang.org/2018/06/21/Rust-1.27.html">Shipped, 1.27</a> </td><td> 2015 </td></tr>
<tr><td> SIMD support </td><td> <a href="https://blog.rust-lang.org/2018/06/21/Rust-1.27.html">Shipped, 1.27</a> </td><td> 2015 </td></tr>
<tr><td> <a href="rust-2018/error-handling-and-panics/question-mark-in-main-and-tests.html"><code>?</code> in <code>main</code>/tests</a> </td><td> <a href="https://blog.rust-lang.org/2018/05/10/Rust-1.26.html">Shipping, 1.26</a> and 1.28 </td><td> 2015 </td></tr>
<tr><td> In-band lifetimes </td><td> Unstable; <a href="https://github.com/rust-lang/rust/issues/44524">tracking issue</a> </td><td> 2015 </td></tr>
<tr><td> <a href="rust-2018/ownership-and-lifetimes/lifetime-elision-in-impl.html">Lifetime elision in <code>impl</code>s</a> </td><td> Unstable; <a href="https://github.com/rust-lang/rust/issues/44524">tracking issue</a> </td><td> 2015 </td></tr>
<tr><td> Non-lexical lifetimes </td><td> <a href="http://smallcultfollowing.com/babysteps/blog/2018/06/15/mir-based-borrow-check-nll-status-update/">Implemented but not ready for preview</a> </td><td> 2015 </td></tr>
<tr><td> <a href="rust-2018/ownership-and-lifetimes/inference-in-structs.html"><code>T: 'a</code> inference in <code>struct</code>s</a> </td><td> Unstable; <a href="https://github.com/rust-lang/rust/issues/44493">tracking issue</a> </td><td> 2015 </td></tr>
<tr><td> <a href="rust-2018/module-system/raw-identifiers.html">Raw identifiers</a> </td><td> Unstable; <a href="https://github.com/rust-lang/rust/issues/48589">tracking issue</a> </td><td> ? </td></tr>
<tr><td> <a href="rust-2018/macros/macro-changes.html">Import macros via <code>use</code></a> </td><td> Unstable; <a href="https://github.com/rust-lang/rust/issues/35896">tracking issue</a> </td><td> ? </td></tr>
<tr><td> <a href="rust-2018/module-system/path-clarity.html">Module system path changes</a> </td><td> Unstable; <a href="https://github.com/rust-lang/rust/issues/44660">tracking issue</a> </td><td> 2018 </td></tr>
</tbody></table>
<p>While some of these features are already available in Rust 2015, they are tracked here
because they are being promoted as part of the Rust 2018 edition.  Accordingly, they
will be discussed in subsequent sections of this guide book. The features marked as
&quot;Shipped&quot; are all available today in stable Rust, so you can start using them right now!</p>
<a class="header" href="#standard-library" id="standard-library"><h2>Standard library</h2></a>
<table><thead><tr><th> <strong>Feature</strong> </th><th> <strong>Status</strong> </th></tr></thead><tbody>
<tr><td> <a href="https://github.com/rust-lang/rust/issues/49668">Custom global allocators</a> </td><td> Will ship in 1.28 </td></tr>
</tbody></table>
<a class="header" href="#tooling" id="tooling"><h2>Tooling</h2></a>
<table><thead><tr><th> <strong>Tool</strong> </th><th> <strong>Status</strong> </th></tr></thead><tbody>
<tr><td> <a href="https://github.com/rust-lang-nursery/rls">RLS</a> 1.0 </td><td> Feature-complete; see <a href="https://github.com/rust-lang-nursery/rls/milestone/7">1.0 milestone</a> </td></tr>
<tr><td> <a href="https://github.com/rust-lang-nursery/rustfmt">rustfmt</a> 1.0 </td><td> Finalizing spec; <a href="https://github.com/rust-lang-nursery/rustfmt/milestone/2">1.0 milestone</a>, <a href="https://github.com/rust-lang/rfcs/pull/2436">style guide RFC</a>, <a href="https://github.com/rust-lang/rfcs/pull/2437">stability RFC</a> </td></tr>
<tr><td> <a href="https://github.com/rust-lang-nursery/rust-clippy">Clippy</a> 1.0 </td><td> <a href="https://github.com/rust-lang/rfcs/pull/2476">RFC</a> </td></tr>
</tbody></table>
<a class="header" href="#documentation-1" id="documentation-1"><h2>Documentation</h2></a>
<table><thead><tr><th> <strong>Tool</strong> </th><th> <strong>Status</strong> </th></tr></thead><tbody>
<tr><td> <a href="https://rust-lang-nursery.github.io/edition-guide/">Edition Guide</a> </td><td> Initial draft complete </td></tr>
<tr><td> <a href="https://github.com/rust-lang/book/">TRPL</a> </td><td> Updated as features stabilize </td></tr>
</tbody></table>
<a class="header" href="#web-site" id="web-site"><h2>Web site</h2></a>
<p>The visual design is being finalized, and early rounds of content brainstorming are complete.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        

        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
        
        

    </body>
</html>
